# Phase 1.5 v2: Расширение 1С -- 5 дополнительных outbound event types

**Проект:** FM-LS-PROFIT (Контроль рентабельности отгрузок по ЛС)
**Версия ФМ:** 1.0.5
**Конфигурация:** 1С:УТ 10.2 | Платформа 8.3 | Обычные формы | Расширение .cfe
**Дата:** 02.03.2026
**Автор:** Шаховский А.С.
**Источник ТЗ:** `AGENT_5_TECH_ARCHITECT/phase1e_integration_architecture.md` (секции 2.6.4--2.6.8)
**Базовая версия:** `phase1_5_extension.md` (v1, 14 объектов, 4 outbound events)
**Issue:** #411 (SE-EXT-001 remediation)
**SE Finding:** SE-EXT-001 (HIGH) -- из 9 outbound event types реализовано только 4 (44%)

---

## 0. Дельта: что добавлено в v2

### Новые outbound event types (5)

| # | Event Type | Kafka Topic | Trigger в 1С:УТ 10.2 | Секция ТЗ |
|---|-----------|-------------|----------------------|-----------|
| 5 | `price.npss-updated` | `1c.price.npss-updated.v1` | Запись в регистр сведений НПСС (SBS-58) | 2.6.4 |
| 6 | `price.purchase-changed` | `1c.price.purchase-changed.v1` | Запись в регистр сведений "Цены контрагентов" | 2.6.5 |
| 7 | `client.updated` | `1c.client.updated.v1` | Запись элемента справочника "Контрагенты" | 2.6.6 |
| 8 | `ls.created` | `1c.ls.created.v1` | Проведение документа "Локальная смета" | 2.6.7 |
| 9 | `ls.plan-changed` | `1c.ls.plan-changed.v1` | Перепроведение документа "Локальная смета" | 2.6.8 |

### Новые объекты метаданных (+5 подписок)

| Объект | Тип | Событие | Обработчик |
|--------|-----|---------|------------|
| ekf_ПриЗаписиНПСС | ПодпискаНаСобытие | ПриЗаписи (РегистрСведений) | ekf_ИнтеграцияСервер.ПриЗаписиНПСС |
| ekf_ПриЗаписиЦенКонтрагентов | ПодпискаНаСобытие | ПриЗаписи (РегистрСведений) | ekf_ИнтеграцияСервер.ПриЗаписиЦенКонтрагентов |
| ekf_ПриЗаписиКонтрагента | ПодпискаНаСобытие | ПриЗаписи (Справочник) | ekf_ИнтеграцияСервер.ПриЗаписиКонтрагента |
| ekf_ПриПроведенииЛокальнойСметы | ПодпискаНаСобытие | ОбработкаПроведения | ekf_ИнтеграцияСервер.ПриПроведенииЛокальнойСметы |
| ekf_ПриПроведенииЛокальнойСметыПлан | ПодпискаНаСобытие | ОбработкаПроведения | ekf_ИнтеграцияСервер.ПриПроведенииЛокальнойСметыПлан |

### Обновленное дерево метаданных (14 -> 19 объектов)

```
Расширение: КонтрольРентабельностиИнтеграция
Режим совместимости: 8.3.9
Назначение: Интеграция 1С:УТ 10.2 с profitability-service через HTTP -> Kafka

Объекты метаданных:
|-- Константы (6)
|   |-- ekf_ИнтеграцияСервисURL          (Строка 200)
|   |-- ekf_ИнтеграцияСервисПорт         (Число 5,0)
|   |-- ekf_ИнтеграцияAPIКлюч            (Строка 100)
|   |-- ekf_ИнтеграцияАктивна            (Булево)
|   |-- ekf_КоллбэкAPIКлюч               (Строка 100)
|   +-- ekf_МаксПопытокОтправки          (Число 3,0) -- по умолчанию 100
|
|-- РегистрыСведений (2)
|   |-- ekf_ОчередьОтправкиСобытий       -- retry queue для исходящих событий
|   +-- ekf_ОбработанныеКоллбэки         -- дедупликация входящих callback
|
|-- ОбщиеМодули (3)
|   |-- ekf_ИнтеграцияСервер             -- основная логика (отправка, retry, JSON, payload)
|   |-- ekf_ИнтеграцияФоновые            -- фоновые задания (retry queue, cleanup)
|   +-- ekf_ИнтеграцияКоллбэкСервер      -- обработка входящих callback
|
|-- HTTPСервисы (1)
|   +-- ekf_КонтрольРентабельностиКоллбэк -- HTTP-сервис для входящих callback
|       |-- КорневойURL: profit-callback/api/v1
|       +-- Шаблоны URL:
|           |-- /callback/approval/{order_id}/result  (PUT)
|           |-- /callback/sanction/{client_id}        (PUT)
|           +-- /callback/block/{order_id}            (PUT)
|
|-- ПодпискиНаСобытия (8)                         <<< БЫЛО 3, СТАЛО 8
|   |-- ekf_ПриПроведенииЗаказаПокупателя          -- order.created / order.updated
|   |-- ekf_ПриПроведенииРеализации                 -- shipment.posted
|   |-- ekf_ПриПроведенииВозврата                    -- shipment.returned
|   |-- ekf_ПриЗаписиНПСС                           -- price.npss-updated       [NEW]
|   |-- ekf_ПриЗаписиЦенКонтрагентов                -- price.purchase-changed   [NEW]
|   |-- ekf_ПриЗаписиКонтрагента                    -- client.updated           [NEW]
|   |-- ekf_ПриПроведенииЛокальнойСметы              -- ls.created              [NEW]
|   +-- ekf_ПриПроведенииЛокальнойСметыПлан          -- ls.plan-changed         [NEW]
|
+-- РегламентныеЗадания (2)
    |-- ekf_ОбработкаОчередиОтправки     -- каждые 60 сек, batch 50
    +-- ekf_ОчисткаОтправленныхСобытий   -- ежедневно 03:00, старше 7 дней
```

**Итого:** 19 объектов метаданных (+5 подписок на события).

---

## 1. Дополнение модуля ekf_ИнтеграцияСервер: 5 новых функций формирования payload

В существующий общий модуль `ekf_ИнтеграцияСервер` (см. `phase1_5_extension.md`, секция 4) добавляются 5 экспортных функций формирования payload. Они размещаются в регионе `ПрограммныйИнтерфейс` после существующих функций `СформироватьДанныеЗаказа`, `СформироватьДанныеОтгрузки`, `СформироватьДанныеВозврата`.

```bsl
// ===========================================================================
// Дополнение модуля: ekf_ИнтеграцияСервер
// Добавлено в v2 (02.03.2026, issue #411)
// ===========================================================================
// Следующие 5 функций добавляются в регион #Область ПрограммныйИнтерфейс
// после существующей функции СформироватьДанныеВозврата().
// ===========================================================================

// Формирует данные события обновления НПСС (нормативной плановой себестоимости).
// Подписка на запись регистра сведений НПСС (проект SBS-58).
//
// Параметры:
//  НаборЗаписей - РегистрСведенийНаборЗаписей - набор записей регистра НПСС
//                  (доступен в обработчике подписки ПриЗаписи)
//  ПредыдущиеЗначения - Соответствие - предыдущие значения НПСС по номенклатуре
//                        (ключ = Номенклатура.Код, значение = НПСС в копейках)
//
// Возвращаемое значение:
//  Массив - массив структур (по одной на каждую изменившуюся запись)
//           для JSON-сериализации по схеме 2.6.4
//
Функция СформироватьДанныеНПСС(НаборЗаписей, ПредыдущиеЗначения) Экспорт

    МассивСобытий = Новый Массив;

    Для Каждого Запись Из НаборЗаписей Цикл

        Данные = Новый Структура;
        Данные.Вставить("product_id", Строка(Запись.Номенклатура.Код));
        Данные.Вставить("npss",       Окр(Запись.НПСС * 100)); // рубли -> копейки

        // Предыдущая НПСС (для расчета delta)
        КодНоменклатуры = Строка(Запись.Номенклатура.Код);
        Если ПредыдущиеЗначения.Получить(КодНоменклатуры) <> Неопределено Тогда
            Данные.Вставить("previous_npss", ПредыдущиеЗначения[КодНоменклатуры]);
        Иначе
            Данные.Вставить("previous_npss", 0);
        КонецЕсли;

        // Метод расчета (плановая / временная)
        Попытка
            МетодРасчета = Строка(Запись.МетодРасчета);
            Если НРег(МетодРасчета) = "временная" Тогда
                Данные.Вставить("method", "temporary");
            Иначе
                Данные.Вставить("method", "planned");
            КонецЕсли;
        Исключение
            Данные.Вставить("method", "planned");
        КонецПопытки;

        // Составляющие НПСС
        Попытка
            Данные.Вставить("purchase_price", Окр(Запись.ЦенаЗакупки * 100));
        Исключение
            Данные.Вставить("purchase_price", 0);
        КонецПопытки;

        Попытка
            Данные.Вставить("logistics_cost", Окр(Запись.ЛогистическиеРасходы * 100));
        Исключение
            Данные.Вставить("logistics_cost", 0);
        КонецПопытки;

        Попытка
            Данные.Вставить("overhead_cost", Окр(Запись.НакладныеРасходы * 100));
        Исключение
            Данные.Вставить("overhead_cost", 0);
        КонецПопытки;

        Данные.Вставить("calculated_at", XMLСтрока(ТекущаяДатаСеанса()));

        // Автор расчета
        Попытка
            Если ЗначениеЗаполнено(Запись.Ответственный) Тогда
                Данные.Вставить("calculated_by", Строка(Запись.Ответственный.Код));
            Иначе
                Данные.Вставить("calculated_by", "");
            КонецЕсли;
        Исключение
            Данные.Вставить("calculated_by", "");
        КонецПопытки;

        МассивСобытий.Добавить(Данные);

    КонецЦикла;

    Возврат МассивСобытий;

КонецФункции

// Формирует данные события изменения закупочной цены.
// Подписка на запись регистра сведений "Цены контрагентов" (срез последних).
//
// Параметры:
//  НаборЗаписей - РегистрСведенийНаборЗаписей - набор записей регистра "Цены контрагентов"
//  ПредыдущиеЦены - Соответствие - предыдущие закупочные цены
//                   (ключ = Номенклатура.Код, значение = Цена в копейках)
//
// Возвращаемое значение:
//  Массив - массив структур для JSON-сериализации по схеме 2.6.5
//
Функция СформироватьДанныеЗакупочнойЦены(НаборЗаписей, ПредыдущиеЦены) Экспорт

    МассивСобытий = Новый Массив;

    Для Каждого Запись Из НаборЗаписей Цикл

        Данные = Новый Структура;
        НоваяЦенаКоп = Окр(Запись.Цена * 100); // рубли -> копейки
        Данные.Вставить("product_id",           Строка(Запись.Номенклатура.Код));
        Данные.Вставить("new_purchase_price",   НоваяЦенаКоп);

        // Предыдущая цена
        КодНоменклатуры = Строка(Запись.Номенклатура.Код);
        ПредЦенаКоп = 0;
        Если ПредыдущиеЦены.Получить(КодНоменклатуры) <> Неопределено Тогда
            ПредЦенаКоп = ПредыдущиеЦены[КодНоменклатуры];
        КонецЕсли;
        Данные.Вставить("previous_purchase_price", ПредЦенаКоп);

        // Отклонение в процентах: (new-old)/old * 100
        Если ПредЦенаКоп > 0 Тогда
            Отклонение = (НоваяЦенаКоп - ПредЦенаКоп) / ПредЦенаКоп * 100;
            Данные.Вставить("deviation_pct", Окр(Отклонение, 2));
        Иначе
            Данные.Вставить("deviation_pct", 0);
        КонецЕсли;

        // Поставщик
        Попытка
            Если ЗначениеЗаполнено(Запись.Контрагент) Тогда
                Данные.Вставить("supplier_id", Строка(Запись.Контрагент.Код));
            Иначе
                Данные.Вставить("supplier_id", "");
            КонецЕсли;
        Исключение
            Данные.Вставить("supplier_id", "");
        КонецПопытки;

        // Происхождение товара
        Попытка
            СтранаПроисхождения = Запись.Номенклатура.СтранаПроисхождения;
            Если ЗначениеЗаполнено(СтранаПроисхождения) Тогда
                КодСтраны = Строка(СтранаПроисхождения.Код);
                Если КодСтраны = "643" Тогда // Россия
                    Данные.Вставить("origin", "domestic");
                Иначе
                    Данные.Вставить("origin", "import");
                КонецЕсли;
            Иначе
                Данные.Вставить("origin", "import"); // по умолчанию -- импорт
            КонецЕсли;
        Исключение
            Данные.Вставить("origin", "import");
        КонецПопытки;

        Данные.Вставить("changed_at", XMLСтрока(ТекущаяДатаСеанса()));

        // Документ-основание (ПТУ или Упаковочный лист)
        Попытка
            Если ЗначениеЗаполнено(Запись.Регистратор) Тогда
                Данные.Вставить("source_document_id", Строка(Запись.Регистратор.Номер));
            Иначе
                Данные.Вставить("source_document_id", "");
            КонецЕсли;
        Исключение
            Данные.Вставить("source_document_id", "");
        КонецПопытки;

        МассивСобытий.Добавить(Данные);

    КонецЦикла;

    Возврат МассивСобытий;

КонецФункции

// Формирует данные события обновления контрагента.
// Подписка на запись элемента справочника "Контрагенты".
//
// Параметры:
//  КонтрагентОбъект - СправочникОбъект.Контрагенты - записываемый элемент
//
// Возвращаемое значение:
//  Структура - данные контрагента для JSON-сериализации по схеме 2.6.6
//
Функция СформироватьДанныеКонтрагента(КонтрагентОбъект) Экспорт

    Данные = Новый Структура;
    Данные.Вставить("client_id", Строка(КонтрагентОбъект.Код));
    Данные.Вставить("name",      КонтрагентОбъект.Наименование);

    // ИНН
    Если ЗначениеЗаполнено(КонтрагентОбъект.ИНН) Тогда
        Данные.Вставить("inn", КонтрагентОбъект.ИНН);
    Иначе
        Данные.Вставить("inn", "");
    КонецЕсли;

    // Признак стратегического клиента
    Попытка
        Данные.Вставить("is_strategic", КонтрагентОбъект.ekf_СтратегическийКлиент);
    Исключение
        // Доп. реквизит ekf_СтратегическийКлиент может отсутствовать
        Данные.Вставить("is_strategic", Ложь);
    КонецПопытки;

    // Критерий стратегичности
    Попытка
        КритерийЗнч = КонтрагентОбъект.ekf_КритерийСтратегичности;
        Если ЗначениеЗаполнено(КритерийЗнч) Тогда
            Данные.Вставить("strategic_criteria", Строка(КритерийЗнч));
        Иначе
            Данные.Вставить("strategic_criteria", Неопределено);
        КонецЕсли;
    Исключение
        Данные.Вставить("strategic_criteria", Неопределено);
    КонецПопытки;

    // Дата присвоения статуса стратегического
    Попытка
        ДатаСтратег = КонтрагентОбъект.ekf_ДатаСтратегическогоСтатуса;
        Если ЗначениеЗаполнено(ДатаСтратег) Тогда
            Данные.Вставить("strategic_since", XMLСтрока(ДатаСтратег));
        Иначе
            Данные.Вставить("strategic_since", Неопределено);
        КонецЕсли;
    Исключение
        Данные.Вставить("strategic_since", Неопределено);
    КонецПопытки;

    // Допустимое отклонение для стратегического клиента (п.п.)
    Попытка
        Данные.Вставить("allowed_deviation", КонтрагентОбъект.ekf_ДопустимоеОтклонение);
    Исключение
        Данные.Вставить("allowed_deviation", 0);
    КонецПопытки;

    // Менеджер
    Попытка
        Если ЗначениеЗаполнено(КонтрагентОбъект.ОсновнойМенеджер) Тогда
            Данные.Вставить("manager_id", Строка(КонтрагентОбъект.ОсновнойМенеджер.Код));
        Иначе
            Данные.Вставить("manager_id", "");
        КонецЕсли;
    Исключение
        Данные.Вставить("manager_id", "");
    КонецПопытки;

    // Подразделение (бизнес-юнит)
    Попытка
        Если ЗначениеЗаполнено(КонтрагентОбъект.ОсновноеПодразделение) Тогда
            Данные.Вставить("business_unit_id",
                Строка(КонтрагентОбъект.ОсновноеПодразделение.Код));
        Иначе
            Данные.Вставить("business_unit_id", "");
        КонецЕсли;
    Исключение
        Данные.Вставить("business_unit_id", "");
    КонецПопытки;

    Данные.Вставить("updated_at", XMLСтрока(ТекущаяДатаСеанса()));

    Возврат Данные;

КонецФункции

// Формирует данные события создания ЛС (Локальной сметы).
// Подписка на проведение документа "Локальная смета".
//
// Параметры:
//  ДокументОбъект - ДокументОбъект.ЛокальнаяСмета - проводимый документ
//
// Возвращаемое значение:
//  Структура - данные ЛС для JSON-сериализации по схеме 2.6.7
//
Функция СформироватьДанныеЛС(ДокументОбъект) Экспорт

    Данные = Новый Структура;
    Данные.Вставить("ls_id",        Строка(ДокументОбъект.Номер));
    Данные.Вставить("client_id",    Строка(ДокументОбъект.Контрагент.Код));

    // Менеджер
    Если ЗначениеЗаполнено(ДокументОбъект.Ответственный) Тогда
        Данные.Вставить("manager_id", Строка(ДокументОбъект.Ответственный.Код));
    Иначе
        Данные.Вставить("manager_id", "");
    КонецЕсли;

    // Подразделение (бизнес-юнит)
    Попытка
        Если ЗначениеЗаполнено(ДокументОбъект.Подразделение) Тогда
            Данные.Вставить("business_unit_id",
                Строка(ДокументОбъект.Подразделение.Код));
        Иначе
            Данные.Вставить("business_unit_id", "");
        КонецЕсли;
    Исключение
        Данные.Вставить("business_unit_id", "");
    КонецПопытки;

    Данные.Вставить("created_at", XMLСтрока(ДокументОбъект.Дата));

    // Срок действия ЛС
    Попытка
        Если ЗначениеЗаполнено(ДокументОбъект.ДатаОкончания) Тогда
            Данные.Вставить("expires_at", XMLСтрока(ДокументОбъект.ДатаОкончания));
        Иначе
            // Если срок не задан, по умолчанию +90 дней
            Данные.Вставить("expires_at", XMLСтрока(ДокументОбъект.Дата + 90 * 86400));
        КонецЕсли;
    Исключение
        Данные.Вставить("expires_at", XMLСтрока(ДокументОбъект.Дата + 90 * 86400));
    КонецПопытки;

    // Плановая рентабельность (basis points = сотые доли %)
    Попытка
        ПлановаяРент = ДокументОбъект.ekf_ПлановаяРентабельность;
        // Значение хранится в процентах (например 15.50), конвертируем в basis points (*100)
        Данные.Вставить("planned_profitability", Окр(ПлановаяРент * 100));
    Исключение
        Данные.Вставить("planned_profitability", 0);
    КонецПопытки;

    // Общая сумма ЛС в копейках
    Данные.Вставить("total_amount", Окр(ДокументОбъект.СуммаДокумента * 100));

    // Строки товаров
    МассивСтрок = Новый Массив;
    Для Каждого СтрокаТовара Из ДокументОбъект.Товары Цикл
        СтруктураСтроки = Новый Структура;
        СтруктураСтроки.Вставить("product_id", Строка(СтрокаТовара.Номенклатура.Код));
        СтруктураСтроки.Вставить("quantity",   СтрокаТовара.Количество);
        СтруктураСтроки.Вставить("price",      Окр(СтрокаТовара.Цена * 100));    // копейки
        СтруктураСтроки.Вставить("amount",     Окр(СтрокаТовара.Сумма * 100));   // копейки

        // Зафиксированная НПСС по строке
        Попытка
            СтруктураСтроки.Вставить("npss", Окр(СтрокаТовара.ekf_НПСС * 100));
        Исключение
            СтруктураСтроки.Вставить("npss", 0);
        КонецПопытки;

        // Подразделение по строке
        Попытка
            Если ЗначениеЗаполнено(СтрокаТовара.Подразделение) Тогда
                СтруктураСтроки.Вставить("business_unit_id",
                    Строка(СтрокаТовара.Подразделение.Код));
            КонецЕсли;
        Исключение
            // Поле Подразделение может отсутствовать в строке
        КонецПопытки;

        МассивСтрок.Добавить(СтруктураСтроки);
    КонецЦикла;
    Данные.Вставить("line_items", МассивСтрок);

    Возврат Данные;

КонецФункции

// Формирует данные события изменения плана ЛС.
// Подписка на перепроведение документа "Локальная смета" с изменением
// плановой рентабельности.
//
// Параметры:
//  ДокументОбъект       - ДокументОбъект.ЛокальнаяСмета - перепроводимый документ
//  ПредыдущаяРентабельность - Число - предыдущая плановая рентабельность в процентах
//
// Возвращаемое значение:
//  Структура - данные изменения плана для JSON-сериализации по схеме 2.6.8
//
Функция СформироватьДанныеИзмененияПланаЛС(ДокументОбъект, ПредыдущаяРентабельность) Экспорт

    Данные = Новый Структура;
    Данные.Вставить("ls_id", Строка(ДокументОбъект.Номер));

    // Предыдущая плановая рентабельность (basis points)
    Данные.Вставить("old_planned_profitability", Окр(ПредыдущаяРентабельность * 100));

    // Новая плановая рентабельность (basis points)
    Попытка
        НоваяРент = ДокументОбъект.ekf_ПлановаяРентабельность;
        Данные.Вставить("new_planned_profitability", Окр(НоваяРент * 100));
    Исключение
        Данные.Вставить("new_planned_profitability", 0);
    КонецПопытки;

    // Причина изменения
    Попытка
        Данные.Вставить("reason", ДокументОбъект.Комментарий);
    Исключение
        Данные.Вставить("reason", "");
    КонецПопытки;

    // Автор изменения
    Попытка
        Если ЗначениеЗаполнено(ДокументОбъект.Ответственный) Тогда
            Данные.Вставить("changed_by", Строка(ДокументОбъект.Ответственный.Код));
        Иначе
            Данные.Вставить("changed_by", "");
        КонецЕсли;
    Исключение
        Данные.Вставить("changed_by", "");
    КонецПопытки;

    Данные.Вставить("changed_at", XMLСтрока(ТекущаяДатаСеанса()));

    Возврат Данные;

КонецФункции
```

---

## 2. Подписки на события: 5 новых обработчиков

### 2.1. Подписка ekf_ПриЗаписиНПСС

**Событие:** ПриЗаписи
**Источник:** РегистрСведений (регистр НПСС, проект SBS-58)
**Обработчик:** ekf_ИнтеграцияСервер.ПриЗаписиНПСС

**Особенность:** Подписка на запись регистра сведений (не документ). Необходимо получить предыдущие значения НПСС до записи для расчета delta. Для этого предварительно читаем текущие значения по номенклатуре из набора записей.

```bsl
// Модуль подписки: ekf_ПриЗаписиНПСС
// Обработчик подписки на событие ПриЗаписи регистра сведений НПСС.
//
// Генерирует событие: "price.npss-updated" -- для каждой изменившейся записи НПСС.
// ТЗ: phase1e, секция 2.6.4 (NPSSUpdatedEvent schema)
//
// Особенности:
//   - Регистр НПСС добавлен проектом SBS-58
//   - Одна запись набора = одна номенклатура
//   - Предыдущие значения запрашиваются из БД до момента записи
//   - Генерируется отдельное событие для каждой номенклатуры

// Обработчик подписки на ПриЗаписи регистра сведений НПСС.
//
// Параметры:
//  Источник - РегистрСведенийНаборЗаписей - набор записей регистра
//  Отказ    - Булево - флаг отказа от записи
//  Замещение - Булево - замещается ли существующая запись
//
Процедура ПриЗаписиНПСС(Источник, Отказ, Замещение) Экспорт

    // Не отправлять событие, если запись уже отменена
    Если Отказ Тогда
        Возврат;
    КонецЕсли;

    // Проверка kill switch
    Если НЕ Константы.ekf_ИнтеграцияАктивна.Получить() Тогда
        Возврат;
    КонецЕсли;

    // Получаем предыдущие значения НПСС для расчета delta
    ПредыдущиеЗначения = ПолучитьПредыдущиеНПСС(Источник);

    // Формируем payload для каждой записи
    МассивСобытий = ekf_ИнтеграцияСервер.СформироватьДанныеНПСС(Источник, ПредыдущиеЗначения);

    // Отправляем каждое событие отдельно
    Для Каждого ДанныеСобытия Из МассивСобытий Цикл
        ekf_ИнтеграцияСервер.ОтправитьСобытие("price.npss-updated", ДанныеСобытия);
    КонецЦикла;

КонецПроцедуры

// Получает предыдущие значения НПСС для номенклатуры из набора записей.
// Вызывается ДО фактической записи набора в БД.
//
// Параметры:
//  НаборЗаписей - РегистрСведенийНаборЗаписей - набор записей для записи
//
// Возвращаемое значение:
//  Соответствие - ключ: Код номенклатуры (Строка), значение: НПСС в копейках (Число)
//
Функция ПолучитьПредыдущиеНПСС(НаборЗаписей)

    Результат = Новый Соответствие;

    // Собираем коды номенклатуры из набора
    МассивНоменклатуры = Новый Массив;
    Для Каждого Запись Из НаборЗаписей Цикл
        МассивНоменклатуры.Добавить(Запись.Номенклатура);
    КонецЦикла;

    Если МассивНоменклатуры.Количество() = 0 Тогда
        Возврат Результат;
    КонецЕсли;

    // Запрашиваем текущие (ещё не перезаписанные) значения НПСС
    Запрос = Новый Запрос;
    Запрос.Текст =
        "ВЫБРАТЬ
        |   НПСС.Номенклатура.Код КАК КодНоменклатуры,
        |   НПСС.НПСС КАК НПСС
        |ИЗ
        |   РегистрСведений.ekf_НПСС.СрезПоследних КАК НПСС
        |ГДЕ
        |   НПСС.Номенклатура В (&СписокНоменклатуры)";
    Запрос.УстановитьПараметр("СписокНоменклатуры", МассивНоменклатуры);

    Попытка
        Выборка = Запрос.Выполнить().Выбрать();
        Пока Выборка.Следующий() Цикл
            Результат.Вставить(Выборка.КодНоменклатуры, Окр(Выборка.НПСС * 100));
        КонецЦикла;
    Исключение
        // Регистр НПСС может иметь другую структуру в конкретной конфигурации.
        // В этом случае все previous_npss будут = 0.
        ЗаписьЖурналаРегистрации(
            "ekf_Интеграция.НПСС",
            УровеньЖурналаРегистрации.Предупреждение, , ,
            "Не удалось получить предыдущие значения НПСС: "
                + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

    Возврат Результат;

КонецФункции
```

### 2.2. Подписка ekf_ПриЗаписиЦенКонтрагентов

**Событие:** ПриЗаписи
**Источник:** РегистрСведений.ЦеныКонтрагентов (регистр закупочных цен поставщиков)
**Обработчик:** ekf_ИнтеграцияСервер.ПриЗаписиЦенКонтрагентов

**Особенность:** Регистр "Цены контрагентов" в 1С:УТ 10.2 -- периодический регистр сведений (срез последних). Записи создаются при проведении документов "Регистрация цен контрагента", "Приобретение товаров и услуг" (ПТУ), "Упаковочный лист".

```bsl
// Модуль подписки: ekf_ПриЗаписиЦенКонтрагентов
// Обработчик подписки на событие ПриЗаписи регистра сведений "Цены контрагентов".
//
// Генерирует событие: "price.purchase-changed" -- для каждой измененной закупочной цены.
// ТЗ: phase1e, секция 2.6.5 (PurchasePriceChangedEvent schema)
//
// Trigger logic (integration-service): при deviation_pct > 15% (LS-BR-075)
// integration-service генерирует evt.integration.price.exchange-trigger.v1
// для оповещения о необходимости пересмотра НПСС в течение 5 рабочих дней.

// Обработчик подписки на ПриЗаписи регистра сведений "Цены контрагентов".
//
// Параметры:
//  Источник - РегистрСведенийНаборЗаписей - набор записей регистра
//  Отказ    - Булево - флаг отказа от записи
//  Замещение - Булево - замещается ли существующая запись
//
Процедура ПриЗаписиЦенКонтрагентов(Источник, Отказ, Замещение) Экспорт

    Если Отказ Тогда
        Возврат;
    КонецЕсли;

    Если НЕ Константы.ekf_ИнтеграцияАктивна.Получить() Тогда
        Возврат;
    КонецЕсли;

    // Получаем предыдущие закупочные цены
    ПредыдущиеЦены = ПолучитьПредыдущиеЦеныКонтрагентов(Источник);

    // Формируем payload
    МассивСобытий = ekf_ИнтеграцияСервер.СформироватьДанныеЗакупочнойЦены(
        Источник, ПредыдущиеЦены);

    // Отправляем каждое событие отдельно (одна запись = один товар)
    Для Каждого ДанныеСобытия Из МассивСобытий Цикл
        ekf_ИнтеграцияСервер.ОтправитьСобытие("price.purchase-changed", ДанныеСобытия);
    КонецЦикла;

КонецПроцедуры

// Получает предыдущие закупочные цены для номенклатуры из набора записей.
//
// Параметры:
//  НаборЗаписей - РегистрСведенийНаборЗаписей - набор записей для записи
//
// Возвращаемое значение:
//  Соответствие - ключ: Код номенклатуры (Строка), значение: Цена в копейках (Число)
//
Функция ПолучитьПредыдущиеЦеныКонтрагентов(НаборЗаписей)

    Результат = Новый Соответствие;

    МассивНоменклатуры = Новый Массив;
    Для Каждого Запись Из НаборЗаписей Цикл
        МассивНоменклатуры.Добавить(Запись.Номенклатура);
    КонецЦикла;

    Если МассивНоменклатуры.Количество() = 0 Тогда
        Возврат Результат;
    КонецЕсли;

    Запрос = Новый Запрос;
    Запрос.Текст =
        "ВЫБРАТЬ
        |   ЦеныКонтрагентов.Номенклатура.Код КАК КодНоменклатуры,
        |   ЦеныКонтрагентов.Цена КАК Цена
        |ИЗ
        |   РегистрСведений.ЦеныКонтрагентов.СрезПоследних КАК ЦеныКонтрагентов
        |ГДЕ
        |   ЦеныКонтрагентов.Номенклатура В (&СписокНоменклатуры)";
    Запрос.УстановитьПараметр("СписокНоменклатуры", МассивНоменклатуры);

    Попытка
        Выборка = Запрос.Выполнить().Выбрать();
        Пока Выборка.Следующий() Цикл
            Результат.Вставить(Выборка.КодНоменклатуры, Окр(Выборка.Цена * 100));
        КонецЦикла;
    Исключение
        ЗаписьЖурналаРегистрации(
            "ekf_Интеграция.ЗакупочнаяЦена",
            УровеньЖурналаРегистрации.Предупреждение, , ,
            "Не удалось получить предыдущие цены контрагентов: "
                + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

    Возврат Результат;

КонецФункции
```

### 2.3. Подписка ekf_ПриЗаписиКонтрагента

**Событие:** ПриЗаписи
**Источник:** Справочник.Контрагенты
**Обработчик:** ekf_ИнтеграцияСервер.ПриЗаписиКонтрагента

**Особенность:** Подписка на запись элемента справочника. Генерирует событие при любом изменении карточки контрагента. Не требует проведения -- справочники записываются напрямую.

```bsl
// Модуль подписки: ekf_ПриЗаписиКонтрагента
// Обработчик подписки на событие ПриЗаписи справочника "Контрагенты".
//
// Генерирует событие: "client.updated"
// ТЗ: phase1e, секция 2.6.6 (ClientUpdatedEvent schema)
//
// Примечание: событие генерируется при ЛЮБОЙ записи элемента справочника
// (создание и изменение). На стороне integration-service выполняется
// upsert контрагента в Mini MDM.

// Обработчик подписки на ПриЗаписи справочника "Контрагенты".
//
// Параметры:
//  Источник - СправочникОбъект.Контрагенты - записываемый элемент
//  Отказ    - Булево - флаг отказа от записи
//
Процедура ПриЗаписиКонтрагента(Источник, Отказ) Экспорт

    Если Отказ Тогда
        Возврат;
    КонецЕсли;

    Если НЕ Константы.ekf_ИнтеграцияАктивна.Получить() Тогда
        Возврат;
    КонецЕсли;

    // Не отправлять событие для групп справочника (только элементы)
    Если Источник.ЭтоГруппа Тогда
        Возврат;
    КонецЕсли;

    ДанныеСобытия = ekf_ИнтеграцияСервер.СформироватьДанныеКонтрагента(Источник);

    ekf_ИнтеграцияСервер.ОтправитьСобытие("client.updated", ДанныеСобытия);

КонецПроцедуры
```

### 2.4. Подписка ekf_ПриПроведенииЛокальнойСметы

**Событие:** ОбработкаПроведения
**Источник:** Документ.ЛокальнаяСмета
**Обработчик:** ekf_ИнтеграцияСервер.ПриПроведенииЛокальнойСметы

**Особенность:** Документ "Локальная смета" существует в разделе "Проекты" 1С:УТ 10.2. При первом проведении генерируется `ls.created`. Определение "нового" проведения аналогично логике заказа -- через проверку наличия предыдущих движений.

```bsl
// Модуль подписки: ekf_ПриПроведенииЛокальнойСметы
// Обработчик подписки на событие ОбработкаПроведения документа "Локальная смета".
//
// Генерирует событие: "ls.created" -- при первом проведении ЛС
// ТЗ: phase1e, секция 2.6.7 (LSCreatedEvent schema)
//
// Примечание: событие ls.created генерируется ТОЛЬКО при первом проведении.
// Перепроведение с изменением плановой рентабельности генерирует ls.plan-changed
// (отдельная подписка ekf_ПриПроведенииЛокальнойСметыПлан).

// Обработчик подписки на ОбработкаПроведения документа "Локальная смета".
//
// Параметры:
//  Источник        - ДокументОбъект.ЛокальнаяСмета - проводимый документ
//  Отказ           - Булево - флаг отказа от проведения
//  РежимПроведения - РежимПроведенияДокумента - оперативный/неоперативный
//
Процедура ПриПроведенииЛокальнойСметы(Источник, Отказ, РежимПроведения) Экспорт

    Если Отказ Тогда
        Возврат;
    КонецЕсли;

    Если НЕ Константы.ekf_ИнтеграцияАктивна.Получить() Тогда
        Возврат;
    КонецЕсли;

    // Определяем, является ли это первым проведением (ls.created)
    Если ЭтоПервоеПроведениеЛС(Источник) Тогда
        ДанныеСобытия = ekf_ИнтеграцияСервер.СформироватьДанныеЛС(Источник);
        ekf_ИнтеграцияСервер.ОтправитьСобытие("ls.created", ДанныеСобытия);
    КонецЕсли;

    // Примечание: ls.plan-changed обрабатывается отдельной подпиской
    // ekf_ПриПроведенииЛокальнойСметыПлан

КонецПроцедуры

// Определяет, является ли текущее проведение первым для данной ЛС.
//
// Параметры:
//  Источник - ДокументОбъект.ЛокальнаяСмета - проводимый документ
//
// Возвращаемое значение:
//  Булево - Истина, если это первое проведение
//
Функция ЭтоПервоеПроведениеЛС(Источник)

    // Если документ совсем новый
    Если Источник.ЭтоНовый() Тогда
        Возврат Истина;
    КонецЕсли;

    // Проверяем, было ли ранее отправлено событие ls.created для этого документа.
    // Используем запрос к очереди отправки -- если есть записи с типом ls.created
    // для данного номера ЛС, значит событие уже отправлялось.
    // Альтернативный подход: проверка движений регистров.
    Запрос = Новый Запрос;
    Запрос.Текст =
        "ВЫБРАТЬ ПЕРВЫЕ 1
        |   1 КАК Поле1
        |ИЗ
        |   РегистрСведений.ekf_ОбработанныеКоллбэки КАК Коллбэки
        |ГДЕ
        |   ЛОЖЬ";

    // Основной способ: проверяем наличие проведенных движений
    // Если документ не новый и есть движения -- это перепроведение
    Попытка
        ЕстьДвижения = НЕ Источник.Движения.Пустой();
        Если ЕстьДвижения Тогда
            Возврат Ложь; // перепроведение, не первое
        КонецЕсли;
    Исключение
        // Если свойство Движения недоступно, используем проверку по регистрам
    КонецПопытки;

    // Fallback: запрос к регистрам
    ЗапросДвиж = Новый Запрос;
    ЗапросДвиж.Текст =
        "ВЫБРАТЬ ПЕРВЫЕ 1
        |   1 КАК Поле1
        |ИЗ
        |   РегистрНакопления.ТоварыНаСкладах.Обороты КАК ТоварыНаСкладахОбороты
        |ГДЕ
        |   ТоварыНаСкладахОбороты.Регистратор = &Ссылка";
    ЗапросДвиж.УстановитьПараметр("Ссылка", Источник.Ссылка);

    Если ЗапросДвиж.Выполнить().Пустой() Тогда
        Возврат Истина;  // первое проведение
    Иначе
        Возврат Ложь;    // перепроведение
    КонецЕсли;

КонецФункции
```

### 2.5. Подписка ekf_ПриПроведенииЛокальнойСметыПлан

**Событие:** ОбработкаПроведения
**Источник:** Документ.ЛокальнаяСмета
**Обработчик:** ekf_ИнтеграцияСервер.ПриПроведенииЛокальнойСметыПлан

**Особенность:** Подписка на перепроведение ЛС, которое изменило плановую рентабельность. Генерирует `ls.plan-changed` ТОЛЬКО если плановая рентабельность фактически изменилась. Работает совместно с подпиской `ekf_ПриПроведенииЛокальнойСметы` -- порядок обработки определяется платформой, конфликтов нет (одна генерирует `ls.created`, другая `ls.plan-changed`, и они взаимно исключающие: created -- только при первом проведении, plan-changed -- только при перепроведении).

```bsl
// Модуль подписки: ekf_ПриПроведенииЛокальнойСметыПлан
// Обработчик подписки на событие ОбработкаПроведения документа "Локальная смета"
// для отслеживания изменения плановой рентабельности.
//
// Генерирует событие: "ls.plan-changed" -- при перепроведении ЛС
// с изменением плановой рентабельности.
// ТЗ: phase1e, секция 2.6.8 (LSPlanChangedEvent schema)
//
// Trigger logic (profitability-service): при получении LSPlanChangedEvent
// запускается CrossValidator -- пересчитывает отклонения всех согласованных
// (но не отгруженных) Заказов по ЛС и при изменении уровня согласования
// отзывает согласование (BR-020/LS-BR-077).

// Обработчик подписки на ОбработкаПроведения документа "Локальная смета"
// для отслеживания изменения плана.
//
// Параметры:
//  Источник        - ДокументОбъект.ЛокальнаяСмета - проводимый документ
//  Отказ           - Булево - флаг отказа от проведения
//  РежимПроведения - РежимПроведенияДокумента - оперативный/неоперативный
//
Процедура ПриПроведенииЛокальнойСметыПлан(Источник, Отказ, РежимПроведения) Экспорт

    Если Отказ Тогда
        Возврат;
    КонецЕсли;

    Если НЕ Константы.ekf_ИнтеграцияАктивна.Получить() Тогда
        Возврат;
    КонецЕсли;

    // Проверяем, изменилась ли плановая рентабельность
    // (только для перепроведений, не для первого проведения)
    Если Источник.ЭтоНовый() Тогда
        Возврат; // первое проведение -- обрабатывается подпиской ekf_ПриПроведенииЛокальнойСметы
    КонецЕсли;

    // Получаем предыдущую плановую рентабельность из БД
    ПредыдущаяРентабельность = ПолучитьПредыдущуюРентабельностьЛС(Источник.Ссылка);

    // Текущая плановая рентабельность
    ТекущаяРентабельность = 0;
    Попытка
        ТекущаяРентабельность = Источник.ekf_ПлановаяРентабельность;
    Исключение
        // Реквизит может отсутствовать
        Возврат;
    КонецПопытки;

    // Генерируем событие только если рентабельность фактически изменилась
    // (сравнение с точностью до 0.01 п.п.)
    Если Окр(ТекущаяРентабельность * 100) = Окр(ПредыдущаяРентабельность * 100) Тогда
        Возврат; // плановая рентабельность не изменилась
    КонецЕсли;

    ДанныеСобытия = ekf_ИнтеграцияСервер.СформироватьДанныеИзмененияПланаЛС(
        Источник, ПредыдущаяРентабельность);

    ekf_ИнтеграцияСервер.ОтправитьСобытие("ls.plan-changed", ДанныеСобытия);

КонецПроцедуры

// Получает предыдущую плановую рентабельность ЛС из базы данных.
// Запрашивает значение реквизита ekf_ПлановаяРентабельность до текущего изменения.
//
// Параметры:
//  СсылкаНаЛС - ДокументСсылка.ЛокальнаяСмета - ссылка на документ
//
// Возвращаемое значение:
//  Число - предыдущая плановая рентабельность в процентах (0 если не найдена)
//
Функция ПолучитьПредыдущуюРентабельностьЛС(СсылкаНаЛС)

    Попытка
        Запрос = Новый Запрос;
        Запрос.Текст =
            "ВЫБРАТЬ
            |   ЛокальнаяСмета.ekf_ПлановаяРентабельность КАК ПлановаяРентабельность
            |ИЗ
            |   Документ.ЛокальнаяСмета КАК ЛокальнаяСмета
            |ГДЕ
            |   ЛокальнаяСмета.Ссылка = &Ссылка";
        Запрос.УстановитьПараметр("Ссылка", СсылкаНаЛС);

        Выборка = Запрос.Выполнить().Выбрать();
        Если Выборка.Следующий() Тогда
            Возврат ?(Выборка.ПлановаяРентабельность = NULL,
                      0, Выборка.ПлановаяРентабельность);
        Иначе
            Возврат 0;
        КонецЕсли;
    Исключение
        // Реквизит ekf_ПлановаяРентабельность может отсутствовать
        ЗаписьЖурналаРегистрации(
            "ekf_Интеграция.ЛС",
            УровеньЖурналаРегистрации.Предупреждение, , ,
            "Не удалось получить предыдущую рентабельность ЛС: "
                + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
        Возврат 0;
    КонецПопытки;

КонецФункции
```

---

## 3. Тестовые сценарии (продолжение нумерации T-33+)

### 3.1. НПСС обновлена (price.npss-updated)

| # | Сценарий | Входные данные | Ожидаемый результат |
|---|----------|---------------|---------------------|
| T-33 | Успешная отправка price.npss-updated | Запись в регистр НПСС, integration-service доступен, ответ 202 | JSON отправлен с полями product_id, npss, previous_npss, method, calculated_at |
| T-34 | Множественная запись НПСС (3 номенклатуры) | Набор из 3 записей регистра НПСС | 3 отдельных события price.npss-updated отправлены |
| T-35 | НПСС с предыдущим значением (delta) | НПСС была 1500, стала 1800 (рублей) | previous_npss=150000, npss=180000 (копейки) |
| T-36 | НПСС без предыдущего значения (новая номенклатура) | Номенклатура не имела НПСС ранее | previous_npss=0, npss=<новое значение> |
| T-37 | Kill switch выключен | ekf_ИнтеграцияАктивна = Ложь | Событие не отправляется |
| T-38 | Метод расчета -- временная | МетодРасчета = "Временная" | method="temporary" |
| T-39 | Составляющие НПСС (purchase_price, logistics_cost, overhead_cost) | Запись со всеми компонентами НПСС | Все 3 поля заполнены в копейках |

### 3.2. Закупочная цена изменена (price.purchase-changed)

| # | Сценарий | Входные данные | Ожидаемый результат |
|---|----------|---------------|---------------------|
| T-40 | Успешная отправка price.purchase-changed | Запись в регистр "Цены контрагентов" | JSON с product_id, new_purchase_price, previous_purchase_price, deviation_pct |
| T-41 | Отклонение > 15% (LS-BR-075 trigger) | Старая цена 1000, новая цена 1200 руб. | deviation_pct=20.00, integration-service сгенерирует exchange-trigger |
| T-42 | Отклонение < 15% (без trigger) | Старая цена 1000, новая цена 1050 руб. | deviation_pct=5.00, no trigger |
| T-43 | Новая номенклатура (нет предыдущей цены) | Первая закупка товара | previous_purchase_price=0, deviation_pct=0 |
| T-44 | Поставщик и документ-основание | Запись от поставщика КА-00001234, ПТУ-00005678 | supplier_id="00001234", source_document_id="00005678" |
| T-45 | Происхождение товара -- отечественный | Страна происхождения = Россия (код 643) | origin="domestic" |
| T-46 | Происхождение товара -- импорт | Страна происхождения = Китай | origin="import" |

### 3.3. Контрагент обновлен (client.updated)

| # | Сценарий | Входные данные | Ожидаемый результат |
|---|----------|---------------|---------------------|
| T-47 | Успешная отправка client.updated | Запись элемента справочника "Контрагенты" | JSON с client_id, name, inn, is_strategic, updated_at |
| T-48 | Стратегический клиент | ekf_СтратегическийКлиент = Истина, критерий = "volume" | is_strategic=true, strategic_criteria="volume" |
| T-49 | Обычный клиент (не стратегический) | ekf_СтратегическийКлиент = Ложь | is_strategic=false, strategic_criteria=null |
| T-50 | Группа справочника -- не отправлять | ЭтоГруппа = Истина | Событие НЕ отправляется |
| T-51 | Контрагент с менеджером и подразделением | ОсновнойМенеджер и ОсновноеПодразделение заполнены | manager_id и business_unit_id заполнены |
| T-52 | Контрагент без доп. реквизитов расширения | Типовой контрагент без ekf_* реквизитов | is_strategic=false, allowed_deviation=0 (graceful) |

### 3.4. ЛС создана (ls.created)

| # | Сценарий | Входные данные | Ожидаемый результат |
|---|----------|---------------|---------------------|
| T-53 | Первое проведение ЛС -> ls.created | Новая ЛС с 5 строками, сумма 500000 руб. | JSON с ls_id, client_id, total_amount=50000000, 5 line_items |
| T-54 | Перепроведение ЛС -> НЕ ls.created | Повторное проведение существующей ЛС | Событие ls.created НЕ отправляется |
| T-55 | ЛС с плановой рентабельностью | ekf_ПлановаяРентабельность = 15.50% | planned_profitability=1550 (basis points) |
| T-56 | ЛС без срока действия | ДатаОкончания не заполнена | expires_at = дата создания + 90 дней |
| T-57 | ЛС с НПСС по строкам | Каждая строка с ekf_НПСС | line_items[].npss заполнена в копейках |
| T-58 | Kill switch выключен | ekf_ИнтеграцияАктивна = Ложь | Событие не отправляется |

### 3.5. План ЛС изменен (ls.plan-changed)

| # | Сценарий | Входные данные | Ожидаемый результат |
|---|----------|---------------|---------------------|
| T-59 | Перепроведение с изменением плана | Рентабельность 15.50% -> 12.30% | JSON с old_planned_profitability=1550, new_planned_profitability=1230 |
| T-60 | Перепроведение БЕЗ изменения плана | Рентабельность 15.50% -> 15.50% | Событие НЕ отправляется (delta = 0) |
| T-61 | Первое проведение -> НЕ plan-changed | Новый документ ЛС | Событие ls.plan-changed НЕ отправляется (Источник.ЭтоНовый() = Истина) |
| T-62 | Причина и автор изменения | Комментарий = "Пересмотр по курсу", Ответственный заполнен | reason="Пересмотр по курсу", changed_by заполнен |
| T-63 | Точность сравнения рентабельности | 15.501% -> 15.509% | Событие НЕ отправляется (разница < 0.01 п.п. в basis points) |
| T-64 | ЛС без доп. реквизита рентабельности | Типовая ЛС без ekf_ПлановаяРентабельность | Событие не отправляется (Исключение -> Возврат) |

---

## 4. Трассировка: Код -> ТЗ -> ФМ (дополнение)

| Модуль / Функция | Требование ТЗ | Раздел ФМ | Описание |
|-----------------|---------------|-----------|----------|
| ekf_ИнтеграцияСервер.СформироватьДанныеНПСС | phase1e, 2.6.4 | п. 3.2, 3.19 | Формирование payload для NPSSUpdatedEvent |
| ekf_ИнтеграцияСервер.СформироватьДанныеЗакупочнойЦены | phase1e, 2.6.5 | LS-BR-075 | Формирование payload для PurchasePriceChangedEvent |
| ekf_ИнтеграцияСервер.СформироватьДанныеКонтрагента | phase1e, 2.6.6 | п. 3.15 | Формирование payload для ClientUpdatedEvent |
| ekf_ИнтеграцияСервер.СформироватьДанныеЛС | phase1e, 2.6.7 | п. 3.1 | Формирование payload для LSCreatedEvent |
| ekf_ИнтеграцияСервер.СформироватьДанныеИзмененияПланаЛС | phase1e, 2.6.8 | п. 3.14 | Формирование payload для LSPlanChangedEvent |
| Подписка ekf_ПриЗаписиНПСС | phase1e, 2.6.4 | п. 3.19 | ПриЗаписи регистра НПСС (SBS-58) |
| Подписка ekf_ПриЗаписиЦенКонтрагентов | phase1e, 2.6.5 | LS-BR-075 | ПриЗаписи регистра "Цены контрагентов" |
| Подписка ekf_ПриЗаписиКонтрагента | phase1e, 2.6.6 | п. 3.15 | ПриЗаписи справочника "Контрагенты" |
| Подписка ekf_ПриПроведенииЛокальнойСметы | phase1e, 2.6.7 | п. 3.1 | &После ОбработкаПроведения ЛС (первое) |
| Подписка ekf_ПриПроведенииЛокальнойСметыПлан | phase1e, 2.6.8 | п. 3.14, LS-BR-077 | &После ОбработкаПроведения ЛС (изменение плана) |

---

## 5. Валидация v2

### 5.1. Чеклист ИТС 455

- [x] Каждый модуль по ИТС 455 (ПрограммныйИнтерфейс / СлужебныеПроцедурыИФункции)
- [x] Нет пустых регионов
- [x] Правильное именование регионов

### 5.2. Качество кода

- [x] Все переменные с комментариями
- [x] Все функции с описанием параметров и возвращаемых значений
- [x] Нет хардкода (настройки в константах)
- [x] Top-to-bottom reading flow
- [x] Graceful degradation (Попытка/Исключение для доп. реквизитов расширения)
- [x] Единообразный стиль с v1 (kill switch, конвертация рубли->копейки, UUID message_id)

### 5.3. Безопасность

- [x] API-ключи хранятся в константах (не в коде)
- [x] Запросы параметризованы (нет конкатенации строк)
- [x] Обработка ошибок с журналированием
- [x] Используется существующий метод ОтправитьСобытие (HTTPS, retry queue)

### 5.4. Совместимость с УТ 10.2

- [x] Нет директив компиляции (&НаСервере, &НаКлиенте)
- [x] Нет Обещание/Ждать (async)
- [x] Все API доступны в платформе 8.3
- [x] Режим совместимости 8.3.9
- [x] Обычные формы -- формы НЕ используются (серверная логика)
- [x] Имена документов -- из УТ 10.2 (ЗаказПокупателя, ЛокальнаяСмета)

### 5.5. Расширение

- [x] Подписки НЕ блокируют UI (таймаут 5 сек, при ошибке -> очередь)
- [x] Все объекты с префиксом ekf_
- [x] Минимальная инвазия -- расширение не модифицирует типовые объекты
- [x] Kill switch проверяется в каждом обработчике подписки
- [x] Доп. реквизиты расширения (ekf_*) обёрнуты в Попытка/Исключение

### 5.6. JSON-схемы (соответствие ТЗ Phase 1E)

- [x] `price.npss-updated` -- все 9 полей из секции 2.6.4 (product_id, npss, previous_npss, method, purchase_price, logistics_cost, overhead_cost, calculated_at, calculated_by)
- [x] `price.purchase-changed` -- все 8 полей из секции 2.6.5 (product_id, new_purchase_price, previous_purchase_price, deviation_pct, supplier_id, origin, changed_at, source_document_id)
- [x] `client.updated` -- все 10 полей из секции 2.6.6 (client_id, name, inn, is_strategic, strategic_criteria, strategic_since, allowed_deviation, manager_id, business_unit_id, updated_at)
- [x] `ls.created` -- все 9 полей из секции 2.6.7 (ls_id, client_id, manager_id, business_unit_id, created_at, expires_at, planned_profitability, total_amount, line_items)
- [x] `ls.plan-changed` -- все 5 полей из секции 2.6.8 (ls_id, old_planned_profitability, new_planned_profitability, reason, changed_by, changed_at)

---

## 6. Ограничения и примечания (дополнение к v1)

6. **Регистр НПСС (SBS-58):** Точное имя регистра и структура полей зависят от реализации проекта SBS-58. В коде используется имя `ekf_НПСС` и поля `Номенклатура`, `НПСС`, `МетодРасчета`, `ЦенаЗакупки`, `ЛогистическиеРасходы`, `НакладныеРасходы`, `Ответственный`. При отличиях в реальной конфигурации -- graceful degradation через Попытка/Исключение.

7. **Регистр "Цены контрагентов":** В 1С:УТ 10.2 это периодический регистр сведений (подчиненный регистратору). Подписка `ПриЗаписи` срабатывает при записи набора записей регистра (при проведении документа-регистратора).

8. **Доп. реквизиты контрагента:** Поля `ekf_СтратегическийКлиент`, `ekf_КритерийСтратегичности`, `ekf_ДатаСтратегическогоСтатуса`, `ekf_ДопустимоеОтклонение` добавляются расширением. Обёрнуты в Попытка/Исключение -- код работает даже без этих реквизитов (с дефолтными значениями).

9. **Документ "Локальная смета":** Существует в разделе "Проекты" 1С:УТ 10.2. Реквизит `ekf_ПлановаяРентабельность` и строчный реквизит `ekf_НПСС` добавляются расширением.

10. **Две подписки на один документ (ЛС):** `ekf_ПриПроведенииЛокальнойСметы` и `ekf_ПриПроведенииЛокальнойСметыПлан` подписаны на одно событие (ОбработкаПроведения) одного источника (ЛокальнаяСмета), но генерируют взаимоисключающие event types: первая -- только при первом проведении, вторая -- только при перепроведении с изменением рентабельности. Порядок вызова подписок не влияет на результат.

11. **Конвертация единиц:** Все суммы конвертируются из рублей в копейки (x100), рентабельность из процентов в basis points (x100). Это соответствует JSON-схемам в ТЗ Phase 1E.

---

## 7. Полная статистика расширения (v1 + v2)

| Метрика | v1 | v2 (дельта) | Итого |
|---------|-----|-------------|-------|
| Объекты метаданных | 14 | +5 подписок | 19 |
| Outbound event types | 4 | +5 | 9/9 (100%) |
| Inbound callback types | 3 | 0 | 3/3 (100%) |
| Функции формирования payload | 3 | +5 | 8 |
| Обработчики подписок | 3 | +5 | 8 |
| Тестовые сценарии | 32 (T-01..T-32) | +32 (T-33..T-64) | 64 |
| Строк BSL (оценка) | ~1600 | ~600 | ~2200 |
| Трассировочных записей | 15 | +10 | 25 |

**SE-EXT-001 remediation:** Покрытие outbound event types увеличено с 44% (4/9) до 100% (9/9).
