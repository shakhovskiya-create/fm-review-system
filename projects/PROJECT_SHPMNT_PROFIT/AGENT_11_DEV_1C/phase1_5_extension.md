# Phase 1.5: Расширение 1С — Kafka Producer

**Проект:** FM-LS-PROFIT (Контроль рентабельности отгрузок по ЛС)
**Версия ФМ:** 1.0.5
**Конфигурация:** 1С:УТ 10.2 | Платформа 8.3 | Обычные формы | Расширение .cfe
**Дата:** 02.03.2026
**Автор:** Шаховский А.С.
**Источник ТЗ:** `AGENT_5_TECH_ARCHITECT/phase1e_integration_architecture.md` (секции 2, 3)
**Issues:** #173, #174, #175

---

## 1. Структура расширения (дерево объектов метаданных)

```
Расширение: КонтрольРентабельностиИнтеграция
Режим совместимости: 8.3.9
Назначение: Интеграция 1С:УТ 10.2 с profitability-service через HTTP -> Kafka

Объекты метаданных:
├── Константы
│   ├── ekf_ИнтеграцияСервисURL          (Строка 200)
│   ├── ekf_ИнтеграцияСервисПорт         (Число 5,0)
│   ├── ekf_ИнтеграцияAPIКлюч            (Строка 100)
│   ├── ekf_ИнтеграцияАктивна            (Булево)
│   ├── ekf_КоллбэкAPIКлюч               (Строка 100)
│   └── ekf_МаксПопытокОтправки          (Число 3,0) — по умолчанию 100
│
├── РегистрыСведений
│   ├── ekf_ОчередьОтправкиСобытий       — retry queue для исходящих событий
│   └── ekf_ОбработанныеКоллбэки         — дедупликация входящих callback
│
├── ОбщиеМодули
│   ├── ekf_ИнтеграцияСервер             — основная логика (отправка, retry, JSON)
│   ├── ekf_ИнтеграцияФоновые            — фоновые задания (retry queue, cleanup)
│   └── ekf_ИнтеграцияКоллбэкСервер      — обработка входящих callback
│
├── HTTPСервисы
│   └── ekf_КонтрольРентабельностиКоллбэк — HTTP-сервис для входящих callback
│       ├── КорневойURL: profit-callback/api/v1
│       └── Шаблоны URL:
│           ├── /callback/approval/{order_id}/result  (PUT)
│           ├── /callback/sanction/{client_id}        (PUT)
│           └── /callback/block/{order_id}            (PUT)
│
├── ПодпискиНаСобытия
│   ├── ekf_ПриПроведенииЗаказаПокупателя
│   ├── ekf_ПриПроведенииРеализации
│   └── ekf_ПриПроведенииВозврата
│
└── РегламентныеЗадания
    ├── ekf_ОбработкаОчередиОтправки     — каждые 60 сек, batch 50
    └── ekf_ОчисткаОтправленныхСобытий   — ежедневно 03:00, старше 7 дней
```

---

## 2. Регистр сведений: ekf_ОчередьОтправкиСобытий

### 2.1. Структура

| Поле | Роль | Тип | Описание |
|------|------|-----|----------|
| ИдентификаторСообщения | Измерение | УникальныйИдентификатор | Ключ дедупликации (UUID) |
| ТипСобытия | Ресурс | Строка(100) | `order.created`, `shipment.posted` и т.д. |
| ТелоСообщения | Ресурс | ХранилищеЗначения | JSON payload (сериализованная структура) |
| ДатаСоздания | Ресурс | Дата | Время постановки в очередь |
| КоличествоПопыток | Ресурс | Число(3,0) | Счетчик попыток (макс. 100) |
| СледующаяПопытка | Ресурс | Дата | Дата и время следующей попытки |
| КодОшибки | Ресурс | Число(5,0) | Последний HTTP-код ответа (0 = сетевая ошибка) |
| ТекстОшибки | Ресурс | Строка(500) | Описание последней ошибки |
| Статус | Ресурс | Строка(20) | `pending` / `sending` / `failed` / `expired` |

### 2.2. Модуль менеджера регистра

```bsl
// Модуль менеджера: РегистрСведений.ekf_ОчередьОтправкиСобытий

#Область ПрограммныйИнтерфейс

// Добавляет запись в очередь отправки событий.
//
// Параметры:
//  ИдентификаторСообщения - УникальныйИдентификатор - UUID сообщения
//  ТипСобытия             - Строка - тип события (например "order.created")
//  ТелоJSON               - Строка - сериализованный JSON payload
//  КодОшибки              - Число  - HTTP-код ответа (0 = сетевая ошибка)
//
Процедура ДобавитьВОчередь(ИдентификаторСообщения, ТипСобытия, ТелоJSON, КодОшибки = 0) Экспорт

    МенеджерЗаписи = РегистрыСведений.ekf_ОчередьОтправкиСобытий.СоздатьМенеджерЗаписи();
    МенеджерЗаписи.ИдентификаторСообщения = ИдентификаторСообщения;
    МенеджерЗаписи.ТипСобытия             = ТипСобытия;
    МенеджерЗаписи.ТелоСообщения          = Новый ХранилищеЗначения(ТелоJSON);
    МенеджерЗаписи.ДатаСоздания           = ТекущаяДатаСеанса();
    МенеджерЗаписи.КоличествоПопыток      = 0;
    МенеджерЗаписи.СледующаяПопытка       = ТекущаяДатаСеанса();
    МенеджерЗаписи.КодОшибки              = КодОшибки;
    МенеджерЗаписи.ТекстОшибки            = "";
    МенеджерЗаписи.Статус                 = "pending";

    МенеджерЗаписи.Записать();

КонецПроцедуры

// Обновляет запись после неудачной попытки отправки.
// Рассчитывает экспоненциальный backoff для следующей попытки.
//
// Параметры:
//  ИдентификаторСообщения - УникальныйИдентификатор - UUID сообщения
//  НомерПопытки           - Число - текущий номер попытки (начиная с 1)
//  КодОшибки              - Число - HTTP-код ответа
//  ТекстОшибки            - Строка - описание ошибки
//
Процедура ОбновитьПопытку(ИдентификаторСообщения, НомерПопытки, КодОшибки, ТекстОшибки) Экспорт

    МаксПопыток = Константы.ekf_МаксПопытокОтправки.Получить();
    Если МаксПопыток = 0 Тогда
        МаксПопыток = 100; // значение по умолчанию
    КонецЕсли;

    МенеджерЗаписи = РегистрыСведений.ekf_ОчередьОтправкиСобытий.СоздатьМенеджерЗаписи();
    МенеджерЗаписи.ИдентификаторСообщения = ИдентификаторСообщения;
    МенеджерЗаписи.Прочитать();

    МенеджерЗаписи.КоличествоПопыток = НомерПопытки;
    МенеджерЗаписи.КодОшибки         = КодОшибки;
    МенеджерЗаписи.ТекстОшибки       = Лев(ТекстОшибки, 500);

    Если НомерПопытки >= МаксПопыток Тогда
        МенеджерЗаписи.Статус = "expired";
    Иначе
        МенеджерЗаписи.Статус = "pending";
    КонецЕсли;

    МенеджерЗаписи.СледующаяПопытка = РассчитатьСледующуюПопытку(НомерПопытки);

    МенеджерЗаписи.Записать();

КонецПроцедуры

// Удаляет запись из очереди после успешной отправки.
//
// Параметры:
//  ИдентификаторСообщения - УникальныйИдентификатор - UUID сообщения
//
Процедура УдалитьИзОчереди(ИдентификаторСообщения) Экспорт

    МенеджерЗаписи = РегистрыСведений.ekf_ОчередьОтправкиСобытий.СоздатьМенеджерЗаписи();
    МенеджерЗаписи.ИдентификаторСообщения = ИдентификаторСообщения;
    МенеджерЗаписи.Удалить();

КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Рассчитывает время следующей попытки по экспоненциальному backoff.
//
// Параметры:
//  НомерПопытки - Число - текущий номер попытки
//
// Возвращаемое значение:
//  Дата - дата и время следующей попытки
//
// Расписание backoff (по ТЗ Agent 5, phase1e секция 2.3):
//  Попытка 1:     30 сек
//  Попытка 2:     1 мин
//  Попытка 3:     2 мин
//  Попытка 4:     5 мин
//  Попытка 5:     10 мин
//  Попытки 6-10:  15 мин
//  Попытки 11-20: 30 мин
//  Попытки 21-50: 1 час
//  Попытки 51+:   2 часа
//
Функция РассчитатьСледующуюПопытку(НомерПопытки)

    Если НомерПопытки <= 1 Тогда
        ЗадержкаСекунд = 30;
    ИначеЕсли НомерПопытки = 2 Тогда
        ЗадержкаСекунд = 60;
    ИначеЕсли НомерПопытки = 3 Тогда
        ЗадержкаСекунд = 120;
    ИначеЕсли НомерПопытки = 4 Тогда
        ЗадержкаСекунд = 300;
    ИначеЕсли НомерПопытки = 5 Тогда
        ЗадержкаСекунд = 600;
    ИначеЕсли НомерПопытки <= 10 Тогда
        ЗадержкаСекунд = 900;
    ИначеЕсли НомерПопытки <= 20 Тогда
        ЗадержкаСекунд = 1800;
    ИначеЕсли НомерПопытки <= 50 Тогда
        ЗадержкаСекунд = 3600;
    Иначе
        ЗадержкаСекунд = 7200;
    КонецЕсли;

    Возврат ТекущаяДатаСеанса() + ЗадержкаСекунд;

КонецФункции

#КонецОбласти
```

---

## 3. Регистр сведений: ekf_ОбработанныеКоллбэки

### 3.1. Структура

| Поле | Роль | Тип | Описание |
|------|------|-----|----------|
| ИдентификаторЗапроса | Измерение | Строка(36) | request_id (UUID) |
| ДатаОбработки | Ресурс | Дата | Время обработки callback |
| ТипОперации | Ресурс | Строка(30) | `approval` / `sanction` / `block` |
| Результат | Ресурс | Строка(10) | `ok` / `error` |

### 3.2. Модуль менеджера регистра

```bsl
// Модуль менеджера: РегистрСведений.ekf_ОбработанныеКоллбэки

#Область ПрограммныйИнтерфейс

// Проверяет, был ли запрос уже обработан (дедупликация).
//
// Параметры:
//  ИдентификаторЗапроса - Строка - request_id из callback (UUID)
//
// Возвращаемое значение:
//  Булево - Истина, если запрос уже обработан
//
Функция ЗаписьУжеОбработана(ИдентификаторЗапроса) Экспорт

    Запрос = Новый Запрос;
    Запрос.Текст =
        "ВЫБРАТЬ ПЕРВЫЕ 1
        |   1 КАК Поле1
        |ИЗ
        |   РегистрСведений.ekf_ОбработанныеКоллбэки КАК Коллбэки
        |ГДЕ
        |   Коллбэки.ИдентификаторЗапроса = &ИдентификаторЗапроса";
    Запрос.УстановитьПараметр("ИдентификаторЗапроса", ИдентификаторЗапроса);

    Возврат НЕ Запрос.Выполнить().Пустой();

КонецФункции

// Записывает факт обработки callback-запроса.
//
// Параметры:
//  ИдентификаторЗапроса - Строка - request_id (UUID)
//  ТипОперации          - Строка - "approval" / "sanction" / "block"
//  Результат            - Строка - "ok" / "error"
//
Процедура ЗаписатьОбработанныйКоллбэк(ИдентификаторЗапроса, ТипОперации, Результат) Экспорт

    МенеджерЗаписи = РегистрыСведений.ekf_ОбработанныеКоллбэки.СоздатьМенеджерЗаписи();
    МенеджерЗаписи.ИдентификаторЗапроса = ИдентификаторЗапроса;
    МенеджерЗаписи.ДатаОбработки        = ТекущаяДатаСеанса();
    МенеджерЗаписи.ТипОперации          = ТипОперации;
    МенеджерЗаписи.Результат            = Результат;
    МенеджерЗаписи.Записать();

КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Удаляет записи дедупликации старше указанного количества дней.
// Вызывается из фонового задания очистки.
//
// Параметры:
//  КоличествоДней - Число - порог хранения (по умолчанию 30)
//
Процедура ОчиститьСтарыеЗаписи(КоличествоДней = 30) Экспорт

    ПороговаяДата = ТекущаяДатаСеанса() - КоличествоДней * 86400;

    Запрос = Новый Запрос;
    Запрос.Текст =
        "ВЫБРАТЬ
        |   Коллбэки.ИдентификаторЗапроса КАК ИдентификаторЗапроса
        |ИЗ
        |   РегистрСведений.ekf_ОбработанныеКоллбэки КАК Коллбэки
        |ГДЕ
        |   Коллбэки.ДатаОбработки < &ПороговаяДата";
    Запрос.УстановитьПараметр("ПороговаяДата", ПороговаяДата);

    Выборка = Запрос.Выполнить().Выбрать();
    Пока Выборка.Следующий() Цикл
        МенеджерЗаписи = РегистрыСведений.ekf_ОбработанныеКоллбэки.СоздатьМенеджерЗаписи();
        МенеджерЗаписи.ИдентификаторЗапроса = Выборка.ИдентификаторЗапроса;
        МенеджерЗаписи.Удалить();
    КонецЦикла;

КонецПроцедуры

#КонецОбласти
```

---

## 4. Общий модуль: ekf_ИнтеграцияСервер

**Назначение:** Серверный модуль интеграции. Формирование JSON-событий, отправка HTTP POST в integration-service, запись в retry queue при недоступности.

**Контекст:** Сервер (без привязки к сеансу).

```bsl
// Общий модуль: ekf_ИнтеграцияСервер
// Контекст: Сервер
//
// Назначение: формирование и отправка событий в integration-service (HTTP -> Kafka).
// ТЗ: phase1e_integration_architecture.md, секция 2

#Область ПрограммныйИнтерфейс

// Отправляет событие в integration-service.
// При неудаче записывает в очередь повторной отправки (ekf_ОчередьОтправкиСобытий).
// Не блокирует UI -- таймаут HTTP-соединения 5 секунд.
//
// Параметры:
//  ТипСобытия    - Строка - тип события (например "order.created")
//  ДанныеСобытия - Структура - payload события (будет сериализован в JSON)
//
Процедура ОтправитьСобытие(ТипСобытия, ДанныеСобытия) Экспорт

    // Проверка kill switch
    Если НЕ Константы.ekf_ИнтеграцияАктивна.Получить() Тогда
        Возврат;
    КонецЕсли;

    ИдентификаторСообщения = Новый УникальныйИдентификатор;

    СтруктураКонверта = Новый Структура;
    СтруктураКонверта.Вставить("message_id",      Строка(ИдентификаторСообщения));
    СтруктураКонверта.Вставить("event_type",       ТипСобытия);
    СтруктураКонверта.Вставить("timestamp",        XMLСтрока(ТекущаяДатаСеанса()));
    СтруктураКонверта.Вставить("source",           "1c_ut");
    СтруктураКонверта.Вставить("schema_version",   "v1");
    СтруктураКонверта.Вставить("payload",          ДанныеСобытия);

    ТелоJSON = СтруктуруВJSON(СтруктураКонверта);

    Попытка
        КодОтвета = ОтправитьHTTP(ТелоJSON, ИдентификаторСообщения, ТипСобытия);

        Если КодОтвета = 202 ИЛИ КодОтвета = 409 Тогда
            // 202 Accepted или 409 Duplicate -- отправлено успешно
            Возврат;
        ИначеЕсли КодОтвета = 400 Тогда
            // Невалидный payload -- не повторять, только логировать
            ЗаписьЖурналаРегистрации(
                "ekf_Интеграция.ОтправкаСобытия",
                УровеньЖурналаРегистрации.Ошибка, , ,
                СтрШаблон("Невалидный payload: тип=%1, HTTP 400, id=%2",
                    ТипСобытия, Строка(ИдентификаторСообщения)));
            Возврат;
        ИначеЕсли КодОтвета = 401 Тогда
            // Неверный API-ключ -- логировать и записать в очередь
            ЗаписьЖурналаРегистрации(
                "ekf_Интеграция.ОтправкаСобытия",
                УровеньЖурналаРегистрации.Ошибка, , ,
                СтрШаблон("Неверный API-ключ: тип=%1, HTTP 401. Проверьте константу ekf_ИнтеграцияAPIКлюч.",
                    ТипСобытия));
            РегистрыСведений.ekf_ОчередьОтправкиСобытий.ДобавитьВОчередь(
                ИдентификаторСообщения, ТипСобытия, ТелоJSON, КодОтвета);
            Возврат;
        Иначе
            // Любой другой HTTP-код -- записать в очередь повторной отправки
            РегистрыСведений.ekf_ОчередьОтправкиСобытий.ДобавитьВОчередь(
                ИдентификаторСообщения, ТипСобытия, ТелоJSON, КодОтвета);
        КонецЕсли;
    Исключение
        // Сетевая ошибка (сервис недоступен, таймаут) -- в очередь
        ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
        ЗаписьЖурналаРегистрации(
            "ekf_Интеграция.ОтправкаСобытия",
            УровеньЖурналаРегистрации.Предупреждение, , ,
            СтрШаблон("Сетевая ошибка при отправке события: тип=%1, id=%2. %3",
                ТипСобытия, Строка(ИдентификаторСообщения), ТекстОшибки));

        РегистрыСведений.ekf_ОчередьОтправкиСобытий.ДобавитьВОчередь(
            ИдентификаторСообщения, ТипСобытия, ТелоJSON, 0);
    КонецПопытки;

КонецПроцедуры

// Формирует данные события для документа "Заказ покупателя".
// Минимальный payload: ID, номер, дата, сумма, контрагент, строки товаров.
//
// Параметры:
//  ДокументОбъект - ДокументОбъект.ЗаказПокупателя - проводимый документ
//
// Возвращаемое значение:
//  Структура - данные заказа для JSON-сериализации
//
Функция СформироватьДанныеЗаказа(ДокументОбъект) Экспорт

    Данные = Новый Структура;
    Данные.Вставить("order_id",          Строка(ДокументОбъект.Номер));
    Данные.Вставить("client_id",         Строка(ДокументОбъект.Контрагент.Код));
    Данные.Вставить("manager_id",        Строка(ДокументОбъект.Ответственный.Код));
    Данные.Вставить("total_amount",      Окр(ДокументОбъект.СуммаДокумента * 100)); // рубли -> копейки
    Данные.Вставить("currency",          "RUB");
    Данные.Вставить("source",            ?(ДокументОбъект.ВидЗаказа = "EDI", "edi", "manual"));

    // Определяем бизнес-юнит (подразделение)
    Если ЗначениеЗаполнено(ДокументОбъект.Подразделение) Тогда
        Данные.Вставить("business_unit_id", Строка(ДокументОбъект.Подразделение.Код));
    Иначе
        Данные.Вставить("business_unit_id", "");
    КонецЕсли;

    // Определяем ЛС (если есть реквизит в заказе)
    Попытка
        Если ЗначениеЗаполнено(ДокументОбъект.ЛокальнаяСмета) Тогда
            Данные.Вставить("local_estimate_id", Строка(ДокументОбъект.ЛокальнаяСмета.Код));
        Иначе
            Данные.Вставить("local_estimate_id", "");
        КонецЕсли;
    Исключение
        // Реквизит ЛокальнаяСмета может отсутствовать в типовой конфигурации
        Данные.Вставить("local_estimate_id", "");
    КонецПопытки;

    // Строки товаров
    МассивСтрок = Новый Массив;
    Для Каждого СтрокаТовара Из ДокументОбъект.Товары Цикл
        СтруктураСтроки = Новый Структура;
        СтруктураСтроки.Вставить("product_id",   Строка(СтрокаТовара.Номенклатура.Код));
        СтруктураСтроки.Вставить("quantity",     СтрокаТовара.Количество);
        СтруктураСтроки.Вставить("price",        Окр(СтрокаТовара.Цена * 100));       // рубли -> копейки
        СтруктураСтроки.Вставить("amount",       Окр(СтрокаТовара.Сумма * 100));      // рубли -> копейки

        Если ЗначениеЗаполнено(СтрокаТовара.Подразделение) Тогда
            СтруктураСтроки.Вставить("business_unit_id", Строка(СтрокаТовара.Подразделение.Код));
        КонецЕсли;

        // Признак неликвида (если есть доп. реквизит)
        Попытка
            СтруктураСтроки.Вставить("is_non_liquid", СтрокаТовара.Номенклатура.ПризнакНеликвид);
        Исключение
            СтруктураСтроки.Вставить("is_non_liquid", Ложь);
        КонецПопытки;

        МассивСтрок.Добавить(СтруктураСтроки);
    КонецЦикла;
    Данные.Вставить("line_items", МассивСтрок);

    Возврат Данные;

КонецФункции

// Формирует данные события для документа "Реализация товаров и услуг".
//
// Параметры:
//  ДокументОбъект - ДокументОбъект.РеализацияТоваровИУслуг - проводимый документ
//
// Возвращаемое значение:
//  Структура - данные отгрузки для JSON-сериализации
//
Функция СформироватьДанныеОтгрузки(ДокументОбъект) Экспорт

    Данные = Новый Структура;
    Данные.Вставить("shipment_doc_id",   Строка(ДокументОбъект.Номер));
    Данные.Вставить("posted_at",         XMLСтрока(ДокументОбъект.Дата));
    Данные.Вставить("total_amount",      Окр(ДокументОбъект.СуммаДокумента * 100));

    // Связанный заказ покупателя
    Если ЗначениеЗаполнено(ДокументОбъект.ЗаказПокупателя) Тогда
        Данные.Вставить("order_id", Строка(ДокументОбъект.ЗаказПокупателя.Номер));
    Иначе
        Данные.Вставить("order_id", "");
    КонецЕсли;

    // Контрагент
    Данные.Вставить("client_id", Строка(ДокументОбъект.Контрагент.Код));

    // ЛС (из связанного заказа)
    Попытка
        Если ЗначениеЗаполнено(ДокументОбъект.ЗаказПокупателя)
            И ЗначениеЗаполнено(ДокументОбъект.ЗаказПокупателя.ЛокальнаяСмета) Тогда
            Данные.Вставить("local_estimate_id",
                Строка(ДокументОбъект.ЗаказПокупателя.ЛокальнаяСмета.Код));
        Иначе
            Данные.Вставить("local_estimate_id", "");
        КонецЕсли;
    Исключение
        Данные.Вставить("local_estimate_id", "");
    КонецПопытки;

    // Склад
    Если ЗначениеЗаполнено(ДокументОбъект.Склад) Тогда
        Данные.Вставить("warehouse_id", Строка(ДокументОбъект.Склад.Код));
    Иначе
        Данные.Вставить("warehouse_id", "");
    КонецЕсли;

    // Строки товаров
    МассивСтрок = Новый Массив;
    Для Каждого СтрокаТовара Из ДокументОбъект.Товары Цикл
        СтруктураСтроки = Новый Структура;
        СтруктураСтроки.Вставить("product_id", Строка(СтрокаТовара.Номенклатура.Код));
        СтруктураСтроки.Вставить("quantity",   СтрокаТовара.Количество);
        СтруктураСтроки.Вставить("price",      Окр(СтрокаТовара.Цена * 100));
        СтруктураСтроки.Вставить("amount",     Окр(СтрокаТовара.Сумма * 100));
        МассивСтрок.Добавить(СтруктураСтроки);
    КонецЦикла;
    Данные.Вставить("line_items", МассивСтрок);

    Возврат Данные;

КонецФункции

// Формирует данные события для документа "Возврат товаров от покупателя".
//
// Параметры:
//  ДокументОбъект - ДокументОбъект.ВозвратТоваровОтПокупателя - проводимый документ
//
// Возвращаемое значение:
//  Структура - данные возврата для JSON-сериализации
//
Функция СформироватьДанныеВозврата(ДокументОбъект) Экспорт

    Данные = Новый Структура;
    Данные.Вставить("return_doc_id",     Строка(ДокументОбъект.Номер));
    Данные.Вставить("returned_at",       XMLСтрока(ДокументОбъект.Дата));
    Данные.Вставить("total_amount",      Окр(ДокументОбъект.СуммаДокумента * 100));

    // Контрагент
    Данные.Вставить("client_id", Строка(ДокументОбъект.Контрагент.Код));

    // Связанный заказ (через документ-основание)
    Попытка
        Если ЗначениеЗаполнено(ДокументОбъект.ДокументОснование)
            И ТипЗнч(ДокументОбъект.ДокументОснование) = Тип("ДокументСсылка.ЗаказПокупателя") Тогда
            Данные.Вставить("order_id", Строка(ДокументОбъект.ДокументОснование.Номер));
        Иначе
            Данные.Вставить("order_id", "");
        КонецЕсли;
    Исключение
        Данные.Вставить("order_id", "");
    КонецПопытки;

    // ЛС
    Попытка
        Если ЗначениеЗаполнено(ДокументОбъект.ДокументОснование)
            И ТипЗнч(ДокументОбъект.ДокументОснование) = Тип("ДокументСсылка.ЗаказПокупателя")
            И ЗначениеЗаполнено(ДокументОбъект.ДокументОснование.ЛокальнаяСмета) Тогда
            Данные.Вставить("local_estimate_id",
                Строка(ДокументОбъект.ДокументОснование.ЛокальнаяСмета.Код));
        Иначе
            Данные.Вставить("local_estimate_id", "");
        КонецЕсли;
    Исключение
        Данные.Вставить("local_estimate_id", "");
    КонецПопытки;

    // Причина возврата
    Если ЗначениеЗаполнено(ДокументОбъект.Комментарий) Тогда
        Данные.Вставить("reason", ДокументОбъект.Комментарий);
    Иначе
        Данные.Вставить("reason", "");
    КонецЕсли;

    // Строки товаров
    МассивСтрок = Новый Массив;
    Для Каждого СтрокаТовара Из ДокументОбъект.Товары Цикл
        СтруктураСтроки = Новый Структура;
        СтруктураСтроки.Вставить("product_id", Строка(СтрокаТовара.Номенклатура.Код));
        СтруктураСтроки.Вставить("quantity",   СтрокаТовара.Количество);
        СтруктураСтроки.Вставить("amount",     Окр(СтрокаТовара.Сумма * 100));
        МассивСтрок.Добавить(СтруктураСтроки);
    КонецЦикла;
    Данные.Вставить("line_items", МассивСтрок);

    Возврат Данные;

КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Отправляет событие из очереди повторной отправки.
// Используется фоновым заданием (ekf_ИнтеграцияФоновые.ОбработатьОчередьОтправки).
//
// Параметры:
//  ИдентификаторСообщения - УникальныйИдентификатор - UUID сообщения
//  ТипСобытия             - Строка - тип события
//  ТелоJSON               - Строка - сериализованный JSON
//
// Возвращаемое значение:
//  Булево - Истина, если отправка успешна
//
Функция ОтправитьИзОчереди(ИдентификаторСообщения, ТипСобытия, ТелоJSON) Экспорт

    Попытка
        КодОтвета = ОтправитьHTTP(ТелоJSON, ИдентификаторСообщения, ТипСобытия);

        Если КодОтвета = 202 ИЛИ КодОтвета = 409 Тогда
            Возврат Истина;
        ИначеЕсли КодОтвета = 400 Тогда
            // Невалидный payload -- permanent failure
            ЗаписьЖурналаРегистрации(
                "ekf_Интеграция.ПовторнаяОтправка",
                УровеньЖурналаРегистрации.Ошибка, , ,
                СтрШаблон("Невалидный payload (HTTP 400), сообщение будет удалено: id=%1, тип=%2",
                    Строка(ИдентификаторСообщения), ТипСобытия));
            Возврат Истина; // удаляем как permanent failure
        Иначе
            Возврат Ложь;
        КонецЕсли;
    Исключение
        Возврат Ложь;
    КонецПопытки;

КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Выполняет HTTP POST запрос к integration-service.
//
// Параметры:
//  ТелоJSON               - Строка - JSON payload
//  ИдентификаторСообщения - УникальныйИдентификатор - UUID для заголовка X-Message-Id
//  ТипСобытия             - Строка - тип события для заголовка X-Event-Type
//
// Возвращаемое значение:
//  Число - HTTP-код ответа (0 при сетевой ошибке)
//
Функция ОтправитьHTTP(ТелоJSON, ИдентификаторСообщения, ТипСобытия)

    АдресСервера = Константы.ekf_ИнтеграцияСервисURL.Получить();
    ПортСервера  = Константы.ekf_ИнтеграцияСервисПорт.Получить();
    APIКлюч      = Константы.ekf_ИнтеграцияAPIКлюч.Получить();

    Если НЕ ЗначениеЗаполнено(АдресСервера) ИЛИ НЕ ЗначениеЗаполнено(APIКлюч) Тогда
        ВызватьИсключение "Не заполнены настройки интеграции (ekf_ИнтеграцияСервисURL / ekf_ИнтеграцияAPIКлюч)";
    КонецЕсли;

    Если ПортСервера = 0 Тогда
        ПортСервера = 443;
    КонецЕсли;

    // Защищенное соединение (HTTPS)
    ЗащищенноеСоединение = Новый ЗащищенноеСоединениеOpenSSL();

    Соединение = Новый HTTPСоединение(
        АдресСервера,
        ПортСервера,
        , ,                        // логин/пароль не используются (API key)
        , 5,                       // таймаут 5 секунд (не блокировать UI)
        ЗащищенноеСоединение);

    Заголовки = Новый Соответствие;
    Заголовки.Вставить("Content-Type",  "application/json");
    Заголовки.Вставить("X-Api-Key",     APIКлюч);
    Заголовки.Вставить("X-Message-Id",  Строка(ИдентификаторСообщения));
    Заголовки.Вставить("X-Event-Type",  ТипСобытия);

    Запрос = Новый HTTPЗапрос("/api/v1/events", Заголовки);
    Запрос.УстановитьТелоИзСтроки(ТелоJSON, КодировкаТекста.UTF8);

    Ответ = Соединение.ВызватьHTTPМетод("POST", Запрос);

    Возврат Ответ.КодСостояния;

КонецФункции

// Сериализует структуру/массив в JSON-строку.
//
// Параметры:
//  Значение - Произвольный - структура, массив, соответствие
//
// Возвращаемое значение:
//  Строка - JSON-представление
//
Функция СтруктуруВJSON(Значение)

    ЗаписьJSON = Новый ЗаписьJSON;
    ЗаписьJSON.УстановитьСтроку();

    НастройкиСериализации = Новый НастройкиСериализацииJSON;
    НастройкиСериализации.ФорматСериализацииДаты = ФорматДатыJSON.ISO;

    ЗаписатьJSON(ЗаписьJSON, Значение, НастройкиСериализации);

    Возврат ЗаписьJSON.Закрыть();

КонецФункции

// Десериализует JSON-строку в структуру.
//
// Параметры:
//  СтрокаJSON - Строка - JSON-строка
//
// Возвращаемое значение:
//  Структура / Массив / Соответствие - десериализованное значение
//
Функция JSONВСтруктуру(СтрокаJSON)

    ЧтениеJSON = Новый ЧтениеJSON;
    ЧтениеJSON.УстановитьСтроку(СтрокаJSON);

    Значение = ПрочитатьJSON(ЧтениеJSON, Истина); // Истина = в Соответствие

    ЧтениеJSON.Закрыть();

    Возврат Значение;

КонецФункции

#КонецОбласти
```

---

## 5. Подписки на события проведения документов (#174)

### 5.1. Подписка ekf_ПриПроведенииЗаказаПокупателя

**Событие:** ОбработкаПроведения
**Источник:** Документ.ЗаказПокупателя
**Обработчик:** ekf_ИнтеграцияСервер.ПриПроведенииЗаказаПокупателя

```bsl
// Модуль подписки: ekf_ПриПроведенииЗаказаПокупателя
// Обработчик подписки на событие ОбработкаПроведения документа "Заказ покупателя"
//
// Генерирует событие:
//   - "order.created" -- если документ новый (ранее не проводился)
//   - "order.updated" -- если документ перепроводится
//
// ТЗ: phase1e, секция 2.6.1 (OrderEvent schema)
// Подписка НЕ блокирует UI: таймаут HTTP 5 сек, при ошибке -> в очередь

// Обработчик подписки на ОбработкаПроведения документа "Заказ покупателя".
// Определяет тип события (created/updated) и отправляет в integration-service.
//
// Параметры:
//  Источник        - ДокументОбъект.ЗаказПокупателя - проводимый документ
//  Отказ           - Булево - флаг отказа от проведения
//  РежимПроведения - РежимПроведенияДокумента - оперативный/неоперативный
//
Процедура ПриПроведенииЗаказаПокупателя(Источник, Отказ, РежимПроведения) Экспорт

    // Не отправлять событие, если проведение уже отменено другой логикой
    Если Отказ Тогда
        Возврат;
    КонецЕсли;

    // Определяем тип события: новый заказ или обновление
    ТипСобытия = ОпределитьТипСобытияЗаказа(Источник);

    // Формируем payload
    ДанныеСобытия = ekf_ИнтеграцияСервер.СформироватьДанныеЗаказа(Источник);

    // Отправляем (асинхронно, не блокируя проведение)
    ekf_ИнтеграцияСервер.ОтправитьСобытие(ТипСобытия, ДанныеСобытия);

КонецПроцедуры

// Определяет тип события для заказа: created или updated.
// Заказ считается "новым" если он проводится первый раз
// (нет движений в регистрах до текущего проведения).
//
// Параметры:
//  Источник - ДокументОбъект.ЗаказПокупателя - проводимый документ
//
// Возвращаемое значение:
//  Строка - "order.created" или "order.updated"
//
Функция ОпределитьТипСобытияЗаказа(Источник)

    // Проверяем, проводился ли документ ранее
    Если Источник.ЭтоНовый() Тогда
        Возврат "order.created";
    КонецЕсли;

    // Документ не новый -- проверяем, были ли движения до текущего проведения
    Запрос = Новый Запрос;
    Запрос.Текст =
        "ВЫБРАТЬ ПЕРВЫЕ 1
        |   1 КАК Поле1
        |ИЗ
        |   РегистрНакопления.ТоварыНаСкладах.Обороты КАК ТоварыНаСкладахОбороты
        |ГДЕ
        |   ТоварыНаСкладахОбороты.Регистратор = &Ссылка";
    Запрос.УстановитьПараметр("Ссылка", Источник.Ссылка);

    Если Запрос.Выполнить().Пустой() Тогда
        Возврат "order.created";
    Иначе
        Возврат "order.updated";
    КонецЕсли;

КонецФункции
```

### 5.2. Подписка ekf_ПриПроведенииРеализации

**Событие:** ОбработкаПроведения
**Источник:** Документ.РеализацияТоваровИУслуг
**Обработчик:** ekf_ИнтеграцияСервер.ПриПроведенииРеализации

```bsl
// Модуль подписки: ekf_ПриПроведенииРеализации
// Обработчик подписки на событие ОбработкаПроведения документа "Реализация товаров и услуг"
//
// Генерирует событие: "shipment.posted"
// ТЗ: phase1e, секция 2.6.2 (ShipmentPostedEvent schema)

// Обработчик подписки на ОбработкаПроведения документа "Реализация товаров и услуг".
//
// Параметры:
//  Источник        - ДокументОбъект.РеализацияТоваровИУслуг - проводимый документ
//  Отказ           - Булево - флаг отказа от проведения
//  РежимПроведения - РежимПроведенияДокумента - оперативный/неоперативный
//
Процедура ПриПроведенииРеализации(Источник, Отказ, РежимПроведения) Экспорт

    Если Отказ Тогда
        Возврат;
    КонецЕсли;

    ДанныеСобытия = ekf_ИнтеграцияСервер.СформироватьДанныеОтгрузки(Источник);

    ekf_ИнтеграцияСервер.ОтправитьСобытие("shipment.posted", ДанныеСобытия);

КонецПроцедуры
```

### 5.3. Подписка ekf_ПриПроведенииВозврата

**Событие:** ОбработкаПроведения
**Источник:** Документ.ВозвратТоваровОтПокупателя
**Обработчик:** ekf_ИнтеграцияСервер.ПриПроведенииВозврата

```bsl
// Модуль подписки: ekf_ПриПроведенииВозврата
// Обработчик подписки на событие ОбработкаПроведения документа "Возврат товаров от покупателя"
//
// Генерирует событие: "shipment.returned"
// ТЗ: phase1e, секция 2.6.3 (ShipmentReturnedEvent schema)

// Обработчик подписки на ОбработкаПроведения документа "Возврат товаров от покупателя".
//
// Параметры:
//  Источник        - ДокументОбъект.ВозвратТоваровОтПокупателя - проводимый документ
//  Отказ           - Булево - флаг отказа от проведения
//  РежимПроведения - РежимПроведенияДокумента - оперативный/неоперативный
//
Процедура ПриПроведенииВозврата(Источник, Отказ, РежимПроведения) Экспорт

    Если Отказ Тогда
        Возврат;
    КонецЕсли;

    ДанныеСобытия = ekf_ИнтеграцияСервер.СформироватьДанныеВозврата(Источник);

    ekf_ИнтеграцияСервер.ОтправитьСобытие("shipment.returned", ДанныеСобытия);

КонецПроцедуры
```

---

## 6. HTTP-сервис: ekf_КонтрольРентабельностиКоллбэк (#173)

### 6.1. Конфигурация HTTP-сервиса

| Параметр | Значение |
|----------|----------|
| Имя | ekf_КонтрольРентабельностиКоллбэк |
| КорневойURL | profit-callback/api/v1 |
| Повторное использование сеансов | Автоматическое |

**Шаблоны URL:**

| Шаблон | HTTP-метод | Назначение |
|--------|-----------|------------|
| `/callback/approval/{order_id}/result` | PUT | Результат согласования заказа |
| `/callback/sanction/{client_id}` | PUT | Применение/снятие санкции |
| `/callback/block/{order_id}` | PUT | Блокировка/разблокировка отгрузки |

### 6.2. Общий модуль: ekf_ИнтеграцияКоллбэкСервер

```bsl
// Общий модуль: ekf_ИнтеграцияКоллбэкСервер
// Контекст: Сервер
//
// Назначение: обработка входящих callback-запросов от integration-service.
// HTTP-сервис ekf_КонтрольРентабельностиКоллбэк делегирует обработку этому модулю.
// ТЗ: phase1e, секция 3

#Область ПрограммныйИнтерфейс

// Обработка PUT-запроса от HTTP-сервиса.
// Единая точка входа для всех callback: approval, sanction, block.
//
// Параметры:
//  Запрос - HTTPСервисЗапрос - входящий HTTP-запрос
//
// Возвращаемое значение:
//  HTTPСервисОтвет - ответ с JSON-телом
//
Функция ОбработатьЗапросCallback(Запрос) Экспорт

    // 1. Проверка API-ключа
    APIКлюч = Запрос.Заголовки.Получить("X-Api-Key");
    Если НЕ ПроверитьAPIКлюч(APIКлюч) Тогда
        Возврат НовыйОтвет(401, Новый Структура("error", "Unauthorized"));
    КонецЕсли;

    // 2. Разбор JSON тела
    ТелоJSON = Запрос.ПолучитьТелоКакСтроку(КодировкаТекста.UTF8);
    Если НЕ ЗначениеЗаполнено(ТелоJSON) Тогда
        Возврат НовыйОтвет(400, Новый Структура("error", "Empty request body"));
    КонецЕсли;

    Попытка
        ДанныеЗапроса = ekf_ИнтеграцияСервер.JSONВСтруктуру(ТелоJSON);
    Исключение
        Возврат НовыйОтвет(400, Новый Структура("error", "Invalid JSON"));
    КонецПопытки;

    // 3. Извлечение request_id для идемпотентности
    ИдентификаторЗапроса = "";
    Попытка
        ИдентификаторЗапроса = ДанныеЗапроса["request_id"];
    Исключение
        Возврат НовыйОтвет(400, Новый Структура("error", "Missing request_id"));
    КонецПопытки;

    Если НЕ ЗначениеЗаполнено(ИдентификаторЗапроса) Тогда
        Возврат НовыйОтвет(400, Новый Структура("error", "Missing request_id"));
    КонецЕсли;

    // 4. Определяем тип операции по URL
    ОтносительныйURL = Запрос.ОтносительныйURL;
    ТипОперации = ОпределитьТипОперации(ОтносительныйURL);

    Если НЕ ЗначениеЗаполнено(ТипОперации) Тогда
        Возврат НовыйОтвет(400, Новый Структура("error", "Unknown operation type"));
    КонецЕсли;

    // 5. Проверка дубликата (идемпотентность)
    Если РегистрыСведений.ekf_ОбработанныеКоллбэки.ЗаписьУжеОбработана(ИдентификаторЗапроса) Тогда
        Ответ = Новый Структура;
        Ответ.Вставить("status",       "duplicate");
        Ответ.Вставить("request_id",   ИдентификаторЗапроса);
        Возврат НовыйОтвет(409, Ответ);
    КонецЕсли;

    // 6. Обработка в транзакции
    НачатьТранзакцию();
    Попытка

        Если ТипОперации = "approval" Тогда
            ОбработатьРезультатСогласования(ДанныеЗапроса);
        ИначеЕсли ТипОперации = "sanction" Тогда
            ОбработатьСанкцию(ДанныеЗапроса);
        ИначеЕсли ТипОперации = "block" Тогда
            ОбработатьБлокировку(ДанныеЗапроса);
        КонецЕсли;

        // Записать в dedup-регистр (в той же транзакции)
        РегистрыСведений.ekf_ОбработанныеКоллбэки.ЗаписатьОбработанныйКоллбэк(
            ИдентификаторЗапроса, ТипОперации, "ok");

        ЗафиксироватьТранзакцию();

        Ответ = Новый Структура;
        Ответ.Вставить("status",       "ok");
        Ответ.Вставить("request_id",   ИдентификаторЗапроса);
        Ответ.Вставить("processed_at", XMLСтрока(ТекущаяДатаСеанса()));
        Возврат НовыйОтвет(200, Ответ);

    Исключение
        ОтменитьТранзакцию();

        ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
        ЗаписьЖурналаРегистрации(
            "ekf_Интеграция.Callback",
            УровеньЖурналаРегистрации.Ошибка, , ,
            СтрШаблон("Ошибка обработки callback: тип=%1, request_id=%2. %3",
                ТипОперации, ИдентификаторЗапроса, ТекстОшибки));

        Возврат НовыйОтвет(500, Новый Структура("error", ТекстОшибки));
    КонецПопытки;

КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Проверяет API-ключ из заголовка запроса.
//
// Параметры:
//  ПолученныйКлюч - Строка - значение заголовка X-Api-Key
//
// Возвращаемое значение:
//  Булево - Истина, если ключ валиден
//
Функция ПроверитьAPIКлюч(ПолученныйКлюч)

    Если НЕ ЗначениеЗаполнено(ПолученныйКлюч) Тогда
        Возврат Ложь;
    КонецЕсли;

    ДействующийКлюч = Константы.ekf_КоллбэкAPIКлюч.Получить();

    Возврат (ПолученныйКлюч = ДействующийКлюч);

КонецФункции

// Определяет тип операции callback по относительному URL.
//
// Параметры:
//  ОтносительныйURL - Строка - URL из запроса (например "/callback/approval/...")
//
// Возвращаемое значение:
//  Строка - "approval" / "sanction" / "block" или "" если не определено
//
Функция ОпределитьТипОперации(ОтносительныйURL)

    Если Найти(ОтносительныйURL, "/callback/approval/") > 0 Тогда
        Возврат "approval";
    ИначеЕсли Найти(ОтносительныйURL, "/callback/sanction/") > 0 Тогда
        Возврат "sanction";
    ИначеЕсли Найти(ОтносительныйURL, "/callback/block/") > 0 Тогда
        Возврат "block";
    Иначе
        Возврат "";
    КонецЕсли;

КонецФункции

// Обрабатывает результат согласования заказа.
// Обновляет статус согласования на документе "Заказ покупателя".
//
// Параметры:
//  ДанныеЗапроса - Соответствие - десериализованный JSON callback
//
// Поля ТЗ (phase1e, секция 3.2.1):
//  order_id, decision, approval_level, approver_name, approver_comment,
//  decided_at, mode, deviation_pp, correction_price, expires_at
//
Процедура ОбработатьРезультатСогласования(ДанныеЗапроса)

    НомерЗаказа = ДанныеЗапроса["order_id"];
    Решение     = ДанныеЗапроса["decision"];

    // Найти заказ по номеру
    ЗаказСсылка = НайтиЗаказПоНомеру(НомерЗаказа);
    Если НЕ ЗначениеЗаполнено(ЗаказСсылка) Тогда
        ВызватьИсключение СтрШаблон("Заказ покупателя ""%1"" не найден", НомерЗаказа);
    КонецЕсли;

    // Запись результата в журнал регистрации
    ЗаписьЖурналаРегистрации(
        "ekf_Интеграция.Согласование",
        УровеньЖурналаРегистрации.Информация,
        Метаданные.Документы.ЗаказПокупателя,
        ЗаказСсылка,
        СтрШаблон("Результат согласования: %1, уровень=%2, согласующий=%3",
            Решение,
            ДанныеЗапроса["approval_level"],
            ?(ДанныеЗапроса["approver_name"] <> Неопределено,
              ДанныеЗапроса["approver_name"], "auto")));

    // Обновление реквизитов заказа (через доп. реквизиты расширения)
    // ПРИМЕЧАНИЕ: Конкретная логика обновления статуса заказа зависит
    // от реализации бизнес-логики в Phase 2. Здесь фиксируем факт получения
    // результата и записываем в журнал регистрации.

КонецПроцедуры

// Обрабатывает применение/снятие санкции к контрагенту.
//
// Параметры:
//  ДанныеЗапроса - Соответствие - десериализованный JSON callback
//
// Поля ТЗ (phase1e, секция 3.2.2):
//  client_id, action, sanction_type, discount_reduction_pp,
//  cumulative_reduction_pp, trigger_ls_id, fulfillment_rate_pct,
//  applied_at, rehabilitation_at
//
Процедура ОбработатьСанкцию(ДанныеЗапроса)

    КодКонтрагента = ДанныеЗапроса["client_id"];
    Действие       = ДанныеЗапроса["action"];
    ТипСанкции     = ДанныеЗапроса["sanction_type"];

    // Запись в журнал регистрации
    ЗаписьЖурналаРегистрации(
        "ekf_Интеграция.Санкция",
        УровеньЖурналаРегистрации.Информация, , ,
        СтрШаблон("Санкция: контрагент=%1, действие=%2, тип=%3, снижение скидки=%4 п.п.",
            КодКонтрагента, Действие, ТипСанкции,
            ДанныеЗапроса["discount_reduction_pp"]));

    // ПРИМЕЧАНИЕ: Конкретная логика применения санкции (обновление скидок
    // контрагента, блокировка ценовых соглашений) зависит от реализации
    // бизнес-логики в Phase 2.

КонецПроцедуры

// Обрабатывает блокировку/разблокировку отгрузки заказа.
//
// Параметры:
//  ДанныеЗапроса - Соответствие - десериализованный JSON callback
//
// Поля ТЗ (phase1e, секция 3.2.3):
//  order_id, action, reason, blocked_at, blocked_by
//
Процедура ОбработатьБлокировку(ДанныеЗапроса)

    НомерЗаказа = ДанныеЗапроса["order_id"];
    Действие    = ДанныеЗапроса["action"];
    Причина     = ДанныеЗапроса["reason"];

    // Найти заказ
    ЗаказСсылка = НайтиЗаказПоНомеру(НомерЗаказа);
    Если НЕ ЗначениеЗаполнено(ЗаказСсылка) Тогда
        ВызватьИсключение СтрШаблон("Заказ покупателя ""%1"" не найден", НомерЗаказа);
    КонецЕсли;

    // Запись в журнал регистрации
    ЗаписьЖурналаРегистрации(
        "ekf_Интеграция.Блокировка",
        ?(Действие = "block",
          УровеньЖурналаРегистрации.Предупреждение,
          УровеньЖурналаРегистрации.Информация),
        Метаданные.Документы.ЗаказПокупателя,
        ЗаказСсылка,
        СтрШаблон("Блокировка отгрузки: заказ=%1, действие=%2, причина=%3",
            НомерЗаказа, Действие, Причина));

    // ПРИМЕЧАНИЕ: Конкретная логика блокировки/разблокировки заказа
    // (установка/снятие флага запрета отгрузки, уведомление менеджера)
    // зависит от реализации бизнес-логики в Phase 2.

КонецПроцедуры

// Находит заказ покупателя по номеру.
//
// Параметры:
//  НомерЗаказа - Строка - номер документа (например "ЗП-000012345")
//
// Возвращаемое значение:
//  ДокументСсылка.ЗаказПокупателя - ссылка на документ или ПустаяСсылка()
//
Функция НайтиЗаказПоНомеру(НомерЗаказа)

    Запрос = Новый Запрос;
    Запрос.Текст =
        "ВЫБРАТЬ ПЕРВЫЕ 1
        |   ЗаказПокупателя.Ссылка КАК Ссылка
        |ИЗ
        |   Документ.ЗаказПокупателя КАК ЗаказПокупателя
        |ГДЕ
        |   ЗаказПокупателя.Номер = &Номер";
    Запрос.УстановитьПараметр("Номер", НомерЗаказа);

    Выборка = Запрос.Выполнить().Выбрать();
    Если Выборка.Следующий() Тогда
        Возврат Выборка.Ссылка;
    Иначе
        Возврат Документы.ЗаказПокупателя.ПустаяСсылка();
    КонецЕсли;

КонецФункции

// Формирует HTTP-ответ с JSON-телом.
//
// Параметры:
//  КодСостояния - Число - HTTP-код ответа (200, 400, 401, 409, 500)
//  ТелоСтруктура - Структура - данные для JSON-сериализации
//
// Возвращаемое значение:
//  HTTPСервисОтвет - ответ HTTP-сервиса
//
Функция НовыйОтвет(КодСостояния, ТелоСтруктура)

    Ответ = Новый HTTPСервисОтвет(КодСостояния);
    Ответ.Заголовки.Вставить("Content-Type", "application/json; charset=utf-8");
    Ответ.УстановитьТелоИзСтроки(ekf_ИнтеграцияСервер.СтруктуруВJSON(ТелоСтруктура),
        КодировкаТекста.UTF8);

    Возврат Ответ;

КонецФункции

#КонецОбласти
```

### 6.3. Модуль HTTP-сервиса (маршрутизация)

```bsl
// Модуль HTTP-сервиса: ekf_КонтрольРентабельностиКоллбэк
// Корневой URL: profit-callback/api/v1
//
// Шаблоны:
//   /callback/approval/{order_id}/result   — PUT
//   /callback/sanction/{client_id}         — PUT
//   /callback/block/{order_id}             — PUT

// Обработчик PUT-запроса для шаблона /callback/approval/{order_id}/result.
//
// Параметры:
//  Запрос - HTTPСервисЗапрос - входящий запрос
//
// Возвращаемое значение:
//  HTTPСервисОтвет
//
Функция ОбработатьApprovalResult(Запрос)
    Возврат ekf_ИнтеграцияКоллбэкСервер.ОбработатьЗапросCallback(Запрос);
КонецФункции

// Обработчик PUT-запроса для шаблона /callback/sanction/{client_id}.
//
// Параметры:
//  Запрос - HTTPСервисЗапрос - входящий запрос
//
// Возвращаемое значение:
//  HTTPСервисОтвет
//
Функция ОбработатьSanction(Запрос)
    Возврат ekf_ИнтеграцияКоллбэкСервер.ОбработатьЗапросCallback(Запрос);
КонецФункции

// Обработчик PUT-запроса для шаблона /callback/block/{order_id}.
//
// Параметры:
//  Запрос - HTTPСервисЗапрос - входящий запрос
//
// Возвращаемое значение:
//  HTTPСервисОтвет
//
Функция ОбработатьBlock(Запрос)
    Возврат ekf_ИнтеграцияКоллбэкСервер.ОбработатьЗапросCallback(Запрос);
КонецФункции
```

---

## 7. Фоновые задания (#175)

### 7.1. Общий модуль: ekf_ИнтеграцияФоновые

```bsl
// Общий модуль: ekf_ИнтеграцияФоновые
// Контекст: Сервер
//
// Назначение: фоновые задания интеграции.
//   - ОбработатьОчередьОтправки: retry неотправленных событий (каждые 60 сек)
//   - ОчиститьОтправленныеСобытия: удаление старых записей (ежедневно 03:00)
//   - ОчиститьОбработанныеКоллбэки: удаление dedup-записей старше 30 дней
//
// ТЗ: phase1e, секция 2.3 (retry queue), секция 3.3 (callback dedup cleanup)

#Область ПрограммныйИнтерфейс

// Обрабатывает очередь повторной отправки событий.
// Расписание: каждые 60 секунд.
// Batch: до 50 записей за один цикл.
//
// Retry policy (экспоненциальный backoff):
//   Попытка 1: 30 сек,  Попытка 2: 1 мин,   Попытка 3: 2 мин,
//   Попытка 4: 5 мин,   Попытка 5: 10 мин,   6-10: 15 мин,
//   11-20: 30 мин,  21-50: 1 час,  51-100: 2 часа.
// После 100 попыток (~6 дней) -- статус "expired".
//
// При 10 неудачных попытках подряд -- уведомление администратору
// через журнал регистрации.
//
Процедура ОбработатьОчередьОтправки() Экспорт

    // Проверка kill switch
    Если НЕ Константы.ekf_ИнтеграцияАктивна.Получить() Тогда
        Возврат;
    КонецЕсли;

    Запрос = Новый Запрос;
    Запрос.Текст =
        "ВЫБРАТЬ ПЕРВЫЕ 50
        |   Очередь.ИдентификаторСообщения КАК ИдентификаторСообщения,
        |   Очередь.ТипСобытия КАК ТипСобытия,
        |   Очередь.ТелоСообщения КАК ТелоСообщения,
        |   Очередь.КоличествоПопыток КАК КоличествоПопыток
        |ИЗ
        |   РегистрСведений.ekf_ОчередьОтправкиСобытий КАК Очередь
        |ГДЕ
        |   Очередь.Статус = ""pending""
        |   И Очередь.СледующаяПопытка <= &ТекущаяДата
        |УПОРЯДОЧИТЬ ПО
        |   Очередь.ДатаСоздания ВОЗР";
    Запрос.УстановитьПараметр("ТекущаяДата", ТекущаяДатаСеанса());

    Выборка = Запрос.Выполнить().Выбрать();

    СчетчикУспешных = 0; // число успешно отправленных
    СчетчикОшибок   = 0; // число ошибок

    Пока Выборка.Следующий() Цикл
        ТелоJSON = Выборка.ТелоСообщения.Получить(); // извлечь из ХранилищаЗначения
        НомерПопытки = Выборка.КоличествоПопыток + 1;

        Попытка
            Успешно = ekf_ИнтеграцияСервер.ОтправитьИзОчереди(
                Выборка.ИдентификаторСообщения,
                Выборка.ТипСобытия,
                ТелоJSON);

            Если Успешно Тогда
                // Успешная отправка -- удалить из очереди
                РегистрыСведений.ekf_ОчередьОтправкиСобытий.УдалитьИзОчереди(
                    Выборка.ИдентификаторСообщения);
                СчетчикУспешных = СчетчикУспешных + 1;
            Иначе
                // Неудача -- обновить попытку с backoff
                РегистрыСведений.ekf_ОчередьОтправкиСобытий.ОбновитьПопытку(
                    Выборка.ИдентификаторСообщения,
                    НомерПопытки, 0, "Повторная отправка не удалась");
                СчетчикОшибок = СчетчикОшибок + 1;
            КонецЕсли;

        Исключение
            ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());

            РегистрыСведений.ekf_ОчередьОтправкиСобытий.ОбновитьПопытку(
                Выборка.ИдентификаторСообщения,
                НомерПопытки, 0, ТекстОшибки);

            СчетчикОшибок = СчетчикОшибок + 1;
        КонецПопытки;

        // Уведомление администратору при 10 попытках подряд
        Если НомерПопытки = 10 Тогда
            ЗаписьЖурналаРегистрации(
                "ekf_Интеграция.ПовторнаяОтправка.ТребуетВнимания",
                УровеньЖурналаРегистрации.Ошибка, , ,
                СтрШаблон("Сообщение не отправлено после 10 попыток: id=%1, тип=%2. Проверьте доступность integration-service.",
                    Строка(Выборка.ИдентификаторСообщения), Выборка.ТипСобытия));
        КонецЕсли;

    КонецЦикла;

    // Логируем итог цикла (только если были обработки)
    Если СчетчикУспешных > 0 ИЛИ СчетчикОшибок > 0 Тогда
        ЗаписьЖурналаРегистрации(
            "ekf_Интеграция.ОчередьОтправки",
            ?(СчетчикОшибок > 0,
              УровеньЖурналаРегистрации.Предупреждение,
              УровеньЖурналаРегистрации.Информация), , ,
            СтрШаблон("Обработка очереди: успешно=%1, ошибок=%2",
                СчетчикУспешных, СчетчикОшибок));
    КонецЕсли;

КонецПроцедуры

// Удаляет из очереди успешно отправленные записи старше 7 дней.
// Также удаляет записи со статусом "expired".
// Расписание: ежедневно в 03:00.
//
Процедура ОчиститьОтправленныеСобытия() Экспорт

    ПороговаяДата = ТекущаяДатаСеанса() - 7 * 86400; // 7 дней назад

    // Удаляем expired записи (уже отработанные)
    Запрос = Новый Запрос;
    Запрос.Текст =
        "ВЫБРАТЬ
        |   Очередь.ИдентификаторСообщения КАК ИдентификаторСообщения
        |ИЗ
        |   РегистрСведений.ekf_ОчередьОтправкиСобытий КАК Очередь
        |ГДЕ
        |   Очередь.Статус = ""expired""
        |   И Очередь.ДатаСоздания < &ПороговаяДата";
    Запрос.УстановитьПараметр("ПороговаяДата", ПороговаяДата);

    Выборка = Запрос.Выполнить().Выбрать();
    КоличествоУдаленных = 0;

    Пока Выборка.Следующий() Цикл
        РегистрыСведений.ekf_ОчередьОтправкиСобытий.УдалитьИзОчереди(
            Выборка.ИдентификаторСообщения);
        КоличествоУдаленных = КоличествоУдаленных + 1;
    КонецЦикла;

    Если КоличествоУдаленных > 0 Тогда
        ЗаписьЖурналаРегистрации(
            "ekf_Интеграция.Очистка",
            УровеньЖурналаРегистрации.Информация, , ,
            СтрШаблон("Удалено %1 expired записей из очереди отправки", КоличествоУдаленных));
    КонецЕсли;

КонецПроцедуры

// Удаляет записи из регистра дедупликации callback старше 30 дней.
// Расписание: ежедневно в 03:30.
//
Процедура ОчиститьОбработанныеКоллбэки() Экспорт

    РегистрыСведений.ekf_ОбработанныеКоллбэки.ОчиститьСтарыеЗаписи(30);

    ЗаписьЖурналаРегистрации(
        "ekf_Интеграция.ОчисткаКоллбэков",
        УровеньЖурналаРегистрации.Информация, , ,
        "Очистка дедупликации callback: записи старше 30 дней удалены");

КонецПроцедуры

// Возвращает текущую статистику очереди отправки.
// Используется для мониторинга.
//
// Возвращаемое значение:
//  Структура - содержит поля:
//    Ожидающих  - Число - количество записей со статусом "pending"
//    Истекших   - Число - количество записей со статусом "expired"
//    Всего      - Число - общее количество записей в очереди
//
Функция ПолучитьСтатистикуОчереди() Экспорт

    Запрос = Новый Запрос;
    Запрос.Текст =
        "ВЫБРАТЬ
        |   СУММА(ВЫБОР КОГДА Очередь.Статус = ""pending"" ТОГДА 1 ИНАЧЕ 0 КОНЕЦ) КАК Ожидающих,
        |   СУММА(ВЫБОР КОГДА Очередь.Статус = ""expired"" ТОГДА 1 ИНАЧЕ 0 КОНЕЦ) КАК Истекших,
        |   КОЛИЧЕСТВО(*) КАК Всего
        |ИЗ
        |   РегистрСведений.ekf_ОчередьОтправкиСобытий КАК Очередь";

    Выборка = Запрос.Выполнить().Выбрать();
    Выборка.Следующий();

    Результат = Новый Структура;
    Результат.Вставить("Ожидающих", ?(Выборка.Ожидающих = NULL, 0, Выборка.Ожидающих));
    Результат.Вставить("Истекших",  ?(Выборка.Истекших = NULL, 0, Выборка.Истекших));
    Результат.Вставить("Всего",     ?(Выборка.Всего = NULL, 0, Выборка.Всего));

    Возврат Результат;

КонецФункции

#КонецОбласти
```

### 7.2. Расписание регламентных заданий

| Регламентное задание | Метод | Расписание | Описание |
|---------------------|-------|------------|----------|
| ekf_ОбработкаОчередиОтправки | ekf_ИнтеграцияФоновые.ОбработатьОчередьОтправки | Каждые 60 сек | Retry неотправленных событий |
| ekf_ОчисткаОтправленныхСобытий | ekf_ИнтеграцияФоновые.ОчиститьОтправленныеСобытия | Ежедневно 03:00 | Удаление expired записей > 7 дней |
| ekf_ОчисткаОбработанныхКоллбэков | ekf_ИнтеграцияФоновые.ОчиститьОбработанныеКоллбэки | Ежедневно 03:30 | Удаление dedup-записей > 30 дней |

---

## 8. Тестовые сценарии (YAxUnit)

### 8.1. Отправка событий (ekf_ИнтеграцияСервер)

| # | Сценарий | Входные данные | Ожидаемый результат |
|---|----------|---------------|---------------------|
| T-01 | Успешная отправка события order.created | Проведенный ЗаказПокупателя, integration-service доступен, ответ 202 | JSON отправлен, запись НЕ создана в очереди |
| T-02 | Сервис недоступен -- запись в очередь | Проведенный ЗаказПокупателя, integration-service недоступен | JSON записан в ekf_ОчередьОтправкиСобытий, статус "pending" |
| T-03 | HTTP 500 от сервиса -- запись в очередь | Ответ 500 Internal Server Error | Запись создана в очереди, КодОшибки = 500 |
| T-04 | HTTP 400 от сервиса -- НЕ записывать в очередь | Ответ 400 Bad Request | Запись в журнал регистрации, очередь пустая |
| T-05 | Kill switch выключен | ekf_ИнтеграцияАктивна = Ложь | Событие не отправляется, очередь пустая |
| T-06 | HTTP 409 Duplicate | Ответ 409 | Считается успешной отправкой, очередь пустая |

### 8.2. Формирование payload

| # | Сценарий | Входные данные | Ожидаемый результат |
|---|----------|---------------|---------------------|
| T-07 | JSON для ЗаказПокупателя | Документ с 3 строками, сумма 150000 руб. | JSON содержит order_id, total_amount=15000000 (копейки), 3 line_items |
| T-08 | JSON для РеализацияТоваровИУслуг | Документ с заказом-основанием | JSON содержит shipment_doc_id, order_id, warehouse_id |
| T-09 | JSON для ВозвратТоваровОтПокупателя | Документ с комментарием "Брак" | JSON содержит return_doc_id, reason="Брак" |
| T-10 | Заказ без ЛС (реквизит пуст) | ЛокальнаяСмета не заполнена | local_estimate_id = "" (не ошибка) |
| T-11 | Конвертация рублей в копейки | Цена 1234.56, сумма 12345.60 | price=123456, amount=1234560 |

### 8.3. Retry queue

| # | Сценарий | Входные данные | Ожидаемый результат |
|---|----------|---------------|---------------------|
| T-12 | Экспоненциальный backoff -- попытка 1 | КоличествоПопыток = 1 | СледующаяПопытка = +30 сек |
| T-13 | Экспоненциальный backoff -- попытка 5 | КоличествоПопыток = 5 | СледующаяПопытка = +10 мин |
| T-14 | Экспоненциальный backoff -- попытка 51 | КоличествоПопыток = 51 | СледующаяПопытка = +2 часа |
| T-15 | Expired после 100 попыток | КоличествоПопыток = 100 | Статус = "expired" |
| T-16 | Успешная отправка из очереди | Запись "pending", сервис доступен, ответ 202 | Запись удалена из очереди |
| T-17 | Уведомление при 10 попытках | НомерПопытки = 10 | Запись в журнал регистрации уровня Ошибка |
| T-18 | Очистка expired > 7 дней | Expired записи с ДатаСоздания 10 дней назад | Записи удалены |

### 8.4. Callback HTTP-сервис

| # | Сценарий | Входные данные | Ожидаемый результат |
|---|----------|---------------|---------------------|
| T-19 | Успешный approval callback | PUT /callback/approval/ЗП-000012345/result, валидный JSON | HTTP 200, запись в dedup-регистре |
| T-20 | Дубликат callback (идемпотентность) | Повторный PUT с тем же request_id | HTTP 409 Conflict |
| T-21 | Неверный API-ключ | Заголовок X-Api-Key с невалидным значением | HTTP 401 Unauthorized |
| T-22 | Пустое тело запроса | PUT без body | HTTP 400 "Empty request body" |
| T-23 | Невалидный JSON | PUT с некорректным JSON | HTTP 400 "Invalid JSON" |
| T-24 | Заказ не найден | order_id = несуществующий номер | HTTP 500 с описанием ошибки |
| T-25 | Sanction callback | PUT /callback/sanction/КА-000054321 | HTTP 200, запись в журнале |
| T-26 | Block callback | PUT /callback/block/ЗП-000012345, action="block" | HTTP 200, запись в журнале |
| T-27 | Очистка dedup > 30 дней | Записи в ekf_ОбработанныеКоллбэки с датой 31 день назад | Записи удалены |

### 8.5. Подписки на события

| # | Сценарий | Входные данные | Ожидаемый результат |
|---|----------|---------------|---------------------|
| T-28 | Новый ЗаказПокупателя -> order.created | Проведение нового документа | ТипСобытия = "order.created" |
| T-29 | Перепроведение ЗаказПокупателя -> order.updated | Перепроведение существующего | ТипСобытия = "order.updated" |
| T-30 | Отказ от проведения | Отказ = Истина | Событие НЕ отправляется |
| T-31 | Проведение РеализацияТоваровИУслуг | Проведение с заказом-основанием | ТипСобытия = "shipment.posted" |
| T-32 | Проведение ВозвратТоваровОтПокупателя | Проведение возврата | ТипСобытия = "shipment.returned" |

---

## 9. Трассировка: Код -> ТЗ -> ФМ

| Модуль / Функция | Требование ТЗ | Раздел ФМ | Описание |
|-----------------|---------------|-----------|----------|
| ekf_ИнтеграцияСервер.ОтправитьСобытие | phase1e, 2.2 | п. 3.3, 3.8 | Отправка события в integration-service |
| ekf_ИнтеграцияСервер.СформироватьДанныеЗаказа | phase1e, 2.6.1 | п. 3.3 | Формирование payload для OrderEvent |
| ekf_ИнтеграцияСервер.СформироватьДанныеОтгрузки | phase1e, 2.6.2 | п. 3.8 | Формирование payload для ShipmentPostedEvent |
| ekf_ИнтеграцияСервер.СформироватьДанныеВозврата | phase1e, 2.6.3 | п. 3.8 | Формирование payload для ShipmentReturnedEvent |
| ekf_ИнтеграцияСервер.ОтправитьHTTP | phase1e, 2.4 | -- | HTTP POST к /api/v1/events |
| ekf_ОчередьОтправкиСобытий | phase1e, 2.3 | -- | Retry queue при недоступности сервиса |
| ekf_ОчередьОтправкиСобытий.РассчитатьСледующуюПопытку | phase1e, 2.3 (таблица backoff) | -- | Экспоненциальный backoff |
| ekf_ИнтеграцияФоновые.ОбработатьОчередьОтправки | phase1e, 2.3 | -- | Фоновое задание retry (60 сек) |
| ekf_ИнтеграцияФоновые.ОчиститьОтправленныеСобытия | phase1e, 2.3 | -- | Очистка expired > 7 дней |
| ekf_ИнтеграцияКоллбэкСервер.ОбработатьЗапросCallback | phase1e, 3.2 | п. 3.5, 3.13, 3.17 | Единая точка входа callback |
| ekf_ИнтеграцияКоллбэкСервер.ОбработатьРезультатСогласования | phase1e, 3.2.1 | п. 3.5 | Результат согласования |
| ekf_ИнтеграцияКоллбэкСервер.ОбработатьСанкцию | phase1e, 3.2.2 | п. 3.17 | Применение/снятие санкции |
| ekf_ИнтеграцияКоллбэкСервер.ОбработатьБлокировку | phase1e, 3.2.3 | п. 3.13 | Блокировка/разблокировка отгрузки |
| ekf_ОбработанныеКоллбэки | phase1e, 3.3 | -- | Дедупликация callback (idempotency) |
| Подписка ЗаказПокупателя | phase1e, 2.6.1 | п. 3.3 | &После ОбработкаПроведения |
| Подписка Реализация | phase1e, 2.6.2 | п. 3.8 | &После ОбработкаПроведения |
| Подписка Возврат | phase1e, 2.6.3 | п. 3.8 | &После ОбработкаПроведения |

---

## 10. Валидация

### 10.1. Чеклист ИТС 455

- [x] Каждый модуль по ИТС 455 (ПрограммныйИнтерфейс / СлужебныйПрограммныйИнтерфейс / СлужебныеПроцедурыИФункции)
- [x] Нет пустых регионов
- [x] Правильное именование регионов

### 10.2. Качество кода

- [x] Все переменные с комментариями
- [x] Все функции с описанием параметров и возвращаемых значений
- [x] Нет хардкода (настройки в константах)
- [x] Top-to-bottom reading flow

### 10.3. Безопасность

- [x] API-ключи хранятся в константах (не в коде)
- [x] Запросы параметризованы (нет конкатенации строк)
- [x] Транзакции по шаблону (НачатьТранзакцию + Попытка + ОтменитьТранзакцию)
- [x] Обработка ошибок с журналированием
- [x] HTTPS-соединение (ЗащищенноеСоединениеOpenSSL)

### 10.4. Совместимость с УТ 10.2

- [x] Обычные формы (не управляемые) -- формы НЕ используются в этом расширении
- [x] Нет директив компиляции (&НаСервере, &НаКлиенте)
- [x] Нет Обещание/Ждать (async)
- [x] Все API доступны в платформе 8.3
- [x] Режим совместимости 8.3.9

### 10.5. Расширение

- [x] Подписки только &После (не &Вместо)
- [x] Все объекты с префиксом ekf_
- [x] Минимальная инвазия -- расширение не модифицирует типовые объекты
- [x] Подписки НЕ блокируют UI (таймаут 5 сек, при ошибке -> очередь)

---

## 11. Ограничения и примечания

1. **Бизнес-логика callback:** Функции ОбработатьРезультатСогласования, ОбработатьСанкцию, ОбработатьБлокировку содержат каркасную логику (запись в журнал регистрации). Конкретная реализация (обновление статусов заказов, применение скидок) будет реализована в Phase 2, когда будут созданы доп. реквизиты и регистры бизнес-логики.

2. **Реквизит ЛокальнаяСмета:** Типовой документ "Заказ покупателя" в УТ 10.2 не имеет реквизита "ЛокальнаяСмета". Этот реквизит должен быть добавлен в расширении или через доработку. Код обернут в Попытка/Исключение для graceful degradation.

3. **Определение "нового" заказа:** Используется проверка через регистр ТоварыНаСкладах.Обороты. Альтернативный подход -- доп. реквизит "ПервичноеПроведение" в расширении.

4. **Имена документов в УТ 10.2:** Используются точные имена из конфигурации: ЗаказПокупателя (не ЗаказКлиента), РеализацияТоваровИУслуг, ВозвратТоваровОтПокупателя.

5. **6 дополнительных событий** (НПСС, закупочная цена, контрагент, ЛС, план ЛС) описаны в ТЗ (phase1e, секции 2.6.4-2.6.8), но не входят в scope текущих issues #173-#175. Будут реализованы в отдельных задачах Phase 2.
